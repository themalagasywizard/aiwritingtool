<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Context Manager - AIStoryCraft</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Merriweather:wght@400;700&display=swap" rel="stylesheet">
    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Frappe Gantt -->
    <script src="https://cdn.jsdelivr.net/npm/frappe-gantt@0.6.1/dist/frappe-gantt.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/frappe-gantt@0.6.1/dist/frappe-gantt.min.css">
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4B5EAA',
                        primaryLight: '#E6E9F0',
                        secondary: '#6B7280',
                        accent: '#F472B6',
                        background: '#F9FAFB',
                        textPrimary: '#1F2937',
                        textSecondary: '#9CA3AF',
                        success: '#34D399',
                        error: '#EF4444',
                        warning: '#FBBF24',
                        location: '#4CAF50',
                        event: '#EF4444',
                        character: '#4B5EAA'
                    }
                }
            }
        }
    </script>
    <style>
        :root {
            --primary: #4B5EAA;
            --primary-light: #E6E9F0;
            --secondary: #6B7280;
            --accent: #F472B6;
            --background: #F9FAFB;
            --text-primary: #1F2937;
            --text-secondary: #9CA3AF;
            --success: #34D399;
            --error: #EF4444;
            --warning: #FBBF24;
            --location: #4CAF50;
            --event: #EF4444;
            --character: #4B5EAA;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background);
            color: var(--text-primary);
        }

        /* Gantt Chart Customization */
        .gantt .bar {
            fill: var(--primary);
        }

        .gantt .bar.location {
            fill: var(--location);
        }

        .gantt .bar.event {
            fill: var(--event);
        }

        .gantt .bar.character {
            fill: var(--character);
        }

        .gantt .bar-label {
            fill: white;
            font-size: 12px;
        }

        .gantt .grid-header {
            fill: var(--background);
            stroke: var(--primary-light);
        }

        .gantt .grid-row {
            fill: white;
        }

        .gantt .row-line {
            stroke: var(--primary-light);
        }

        .gantt .lower-text, .gantt .upper-text {
            fill: var(--text-primary);
            font-size: 12px;
        }

        /* Character Tree Customization */
        .character-tree {
            position: relative;
            min-height: 300px;
            padding: 1rem;
            overflow: visible;
            z-index: 1;
        }

        .character-node {
            position: absolute;
            width: 100px;
            height: 40px;
            border-radius: 20px;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 2;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .character-node.protagonist {
            border: 2px solid var(--primary);
            color: var(--primary);
        }

        .character-node.antagonist {
            border: 2px solid var(--error);
            color: var(--error);
        }

        .character-node.supporting {
            border: 2px solid var(--accent);
            color: var(--accent);
        }

        .character-link {
            position: absolute;
            height: 1px;
            background-color: #ccc;
            transform-origin: 0 0;
            z-index: 1;
            pointer-events: none;
        }

        .character-node:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .role-badge.protagonist {
            background-color: rgba(75, 94, 170, 0.15);
            color: var(--primary);
        }

        .role-badge.antagonist {
            background-color: rgba(239, 68, 68, 0.15);
            color: var(--error);
        }

        .role-badge.supporting {
            background-color: rgba(244, 114, 182, 0.15);
            color: var(--accent);
        }

        /* Timeline Controls */
        .timeline-controls {
            position: sticky;
            top: 0;
            z-index: 30;
            background-color: white;
            border-bottom: 1px solid var(--primary-light);
            padding: 1rem;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: var(--primary-light);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background-color: var(--primary);
            color: white;
            box-shadow: 0 2px 4px rgba(75, 94, 170, 0.2);
        }

        .btn-primary:hover {
            background-color: #3F50A0;
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(75, 94, 170, 0.25);
        }

        /* Role badge styles */
        .role-badge {
            display: inline-flex;
            align-items: center;
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            font-weight: 500;
        }

        /* Modal overlay and container styles */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-container {
            background-color: white;
            border-radius: 0.5rem;
            padding: 1.5rem;
            width: 100%;
            max-width: 32rem;
            z-index: 51;
            position: relative;
        }

        /* Add styles for timeline */
        .timeline-cell {
            min-height: 70px;
            padding: 0;
            vertical-align: top;
            transition: background-color 0.2s;
            position: relative;
        }
        
        .timeline-cell:hover {
            background-color: rgba(75, 94, 170, 0.05);
        }
        
        .timeline-cell.drag-over {
            background-color: rgba(75, 94, 170, 0.1);
            border: 2px dashed var(--primary);
        }
        
        .character-tag {
            position: absolute;
            display: inline-block;
            min-width: 60px;
            margin: 0;
            cursor: move;
            transition: transform 0.1s;
            z-index: 10;
        }
        
        .character-tag:hover {
            transform: translateY(-2px);
            z-index: 20;
        }
        
        .character-item {
            transition: transform 0.1s, opacity 0.2s;
            cursor: move;
        }
        
        .character-item:hover {
            transform: translateY(-2px);
        }
        
        .character-item.dragging {
            opacity: 0.5;
        }
        
        /* Primary color based roles */
        .bg-primary { background-color: var(--primary); }
        .bg-error { background-color: var(--error); }
        .bg-accent { background-color: var(--accent); }
        
        /* Tab styling */
        .tab-btn {
            transition: all 0.2s ease;
        }
        
        .tab-btn.active {
            border-color: var(--primary);
            color: var(--primary);
        }
        
        .tab-content {
            display: block;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        .tab-content.hidden {
            display: none;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
</head>
<body class="h-screen flex flex-col">
    <!-- Header with tabs -->
    <header class="bg-white border-b border-gray-100">
        <div class="container mx-auto px-4 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-4">
                    <a href="index.html" class="text-gray-500 hover:text-primary">
                        <i class="fas fa-arrow-left"></i>
                        <span class="ml-2">Back to Editor</span>
                    </a>
                    <h1 class="text-xl font-semibold text-primary">Context Manager</h1>
                </div>
            </div>
            <!-- Tabs -->
            <div class="flex mt-6 border-b border-gray-200">
                <button class="tab-btn px-4 py-2 border-b-2 border-primary text-primary font-medium" data-tab="timeline">
                    <i class="fas fa-clock mr-2"></i>Story Timeline
                </button>
                <button class="tab-btn px-4 py-2 border-b-2 border-transparent hover:text-primary" data-tab="characters">
                    <i class="fas fa-users mr-2"></i>Characters
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto px-4 py-6">
        <!-- Timeline Tab View -->
        <div class="tab-content" id="timelineTab">
            <div class="flex h-[calc(100vh-170px)]">
                <!-- Characters Sidebar (Left) -->
                <div class="w-64 bg-white shadow-md border border-gray-100 rounded-l-lg overflow-y-auto">
                    <div class="p-4 border-b border-gray-100">
                        <h2 class="text-lg font-semibold text-primary">Characters</h2>
                        <p class="text-sm text-gray-500 mt-1">Drag characters to the timeline</p>
                    </div>
                    <div id="charactersList" class="p-4 space-y-2">
                        <!-- Character items for dragging -->
                        <div class="character-item bg-white border-2 border-primary text-primary p-2 rounded-lg cursor-move shadow-sm" 
                             draggable="true" data-name="Elizabeth" data-color="blue" data-role="Protagonist">
                            <div class="text-sm font-medium">Elizabeth</div>
                        </div>
                        <div class="character-item bg-white border-2 border-error text-error p-2 rounded-lg cursor-move shadow-sm" 
                             draggable="true" data-name="James" data-color="red" data-role="Antagonist">
                            <div class="text-sm font-medium">James</div>
                        </div>
                        <div class="character-item bg-white border-2 border-accent text-accent p-2 rounded-lg cursor-move shadow-sm" 
                             draggable="true" data-name="Sarah" data-color="green" data-role="Supporting">
                            <div class="text-sm font-medium">Sarah</div>
                        </div>
                    </div>
                </div>

                <!-- Timeline Gantt Chart (Right) -->
                <div class="flex-1 bg-white shadow-md border border-gray-100 rounded-r-lg overflow-auto">
                    <div class="p-4 border-b border-gray-100 flex justify-between items-center sticky top-0 bg-white z-10">
                        <h2 class="text-lg font-semibold text-primary">Story Timeline</h2>
                        <div class="flex items-center space-x-3">
                            <select id="daySelector" class="border border-gray-200 rounded-lg p-2 text-sm">
                                <option value="1">Day 1</option>
                                <option value="2">Day 2</option>
                                <option value="3">Day 3</option>
                                <option value="4">Day 4</option>
                                <option value="5">Day 5</option>
                            </select>
                            <button class="btn btn-primary text-xs py-1 px-2" id="addLocationBtn" title="Add Location">
                                <i class="fas fa-plus text-xs mr-1"></i>Add Location
                            </button>
                        </div>
                    </div>

                    <!-- Timeline Grid -->
                    <div class="p-4">
                        <div class="timeline-grid border border-gray-200 rounded-lg overflow-x-auto">
                            <table class="w-full min-w-max">
                                <thead>
                                    <tr>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-3 text-left"></th>
                                        <!-- Generate 24 columns for each hour -->
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">00:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">01:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">02:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">03:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">04:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">05:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">06:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">07:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">08:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">09:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">10:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">11:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">12:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">13:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">14:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">15:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">16:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">17:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">18:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">19:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">20:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">21:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">22:00</th>
                                        <th class="w-20 border-b border-gray-200 bg-gray-50 p-2 text-center">23:00</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td class="border-r border-b border-gray-200 p-3 font-medium">Castle</td>
                                        <!-- Generate 24 cells for each hour -->
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="0" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="1" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="2" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="3" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="4" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="5" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="6" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="7" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="8" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="9" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="10" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="11" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="12" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="13" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="14" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="15" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="16" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="17" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="18" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="19" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="20" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="21" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="22" data-location="Castle"></td>
                                        <td class="border-b border-gray-200 timeline-cell relative" data-time="23" data-location="Castle"></td>
                                    </tr>
                                    <!-- Repeat similar structure for other locations -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Characters Tab View -->
        <div class="tab-content hidden" id="charactersTab">
            <!-- Character Tree View -->
            <div class="bg-white shadow-md border border-gray-100 rounded-lg p-6">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-semibold text-primary">Characters Network</h2>
                    <button class="btn btn-primary text-sm" onclick="openModal('character')">
                        <i class="fas fa-plus text-sm mr-1"></i>
                        New Character
                    </button>
                </div>
                
                <div class="character-tree relative p-8 min-h-[400px] border border-gray-100 rounded-lg mb-6" id="characterTreeContainer">
                    <!-- Character nodes positioned to match reference image -->
                    <div class="character-node protagonist" style="top: 120px; left: 50%; transform: translateX(-50%);" data-name="John Doe" data-role="Protagonist" data-traits="Brave, curious explorer" data-backstory="Survived an accident in New York">
                        <div class="font-medium text-center">John</div>
                    </div>
                    <div class="character-node antagonist" style="top: 220px; left: 30%;" data-name="Mystery Figure" data-role="Antagonist" data-traits="Enigmatic, threatening" data-backstory="Unknown entity connected to the accident">
                        <div class="font-medium text-center">Mystery</div>
                    </div>
                    <div class="character-node supporting" style="top: 220px; left: 70%;" data-name="Sarah" data-role="Supporting" data-traits="Supportive, knowledgeable" data-backstory="John's friend who helps him navigate his return">
                        <div class="font-medium text-center">Sarah</div>
                    </div>
                    
                    <!-- Predefined connection lines like in the reference image -->
                    <div class="character-link" style="width: 225px; top: 140px; left: 50%; transform: rotate(45deg) translateX(-50%);"></div>
                    <div class="character-link" style="width: 225px; top: 140px; left: 50%; transform: rotate(-45deg) translateX(-50%);"></div>
                </div>
                
                <div class="flex justify-center space-x-6 text-sm">
                    <div class="flex items-center">
                        <div class="w-3 h-3 rounded-full bg-primary mr-2"></div>
                        <span>Protagonist</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-3 h-3 rounded-full bg-error mr-2"></div>
                        <span>Antagonist</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-3 h-3 rounded-full bg-accent mr-2"></div>
                        <span>Supporting</span>
                    </div>
                </div>
            </div>
            
            <!-- Character Details Panel -->
            <div id="characterDetailsPanel" class="fixed inset-y-0 right-0 w-96 bg-white shadow-lg transform translate-x-full transition-transform duration-300 z-50">
                <div class="h-full flex flex-col">
                    <div class="p-6 border-b border-gray-100">
                        <div class="flex items-center justify-between mb-4">
                            <h2 class="text-xl font-bold text-primary" id="characterDetailName">Character Name</h2>
                            <button class="text-gray-400 hover:text-gray-600" onclick="closeCharacterDetails()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="inline-flex items-center px-3 py-1 rounded-full text-sm" id="characterDetailRole">
                            Role
                        </div>
                    </div>
                    
                    <div class="flex-1 overflow-y-auto p-6">
                        <div class="space-y-6">
                            <div>
                                <h3 class="text-sm font-semibold text-gray-500 uppercase tracking-wider mb-2">Traits</h3>
                                <p class="text-gray-700" id="characterDetailTraits">Character traits will appear here</p>
                            </div>
                            
                            <div>
                                <h3 class="text-sm font-semibold text-gray-500 uppercase tracking-wider mb-2">Backstory</h3>
                                <p class="text-gray-700" id="characterDetailBackstory">Character backstory will appear here</p>
                            </div>
                            
                            <div>
                                <h3 class="text-sm font-semibold text-gray-500 uppercase tracking-wider mb-2">Relationships</h3>
                                <div class="space-y-2" id="characterDetailRelationships">
                                    <!-- Relationships will be added here -->
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="p-6 border-t border-gray-100">
                        <button class="btn btn-primary w-full" id="editCharacterBtn">
                            <i class="fas fa-edit mr-2"></i>
                            Edit Character
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Add Item Modal -->
    <div id="addItemModal" class="modal-overlay hidden">
        <div class="modal-container">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-xl font-bold text-primary">Edit Character</h2>
                <button onclick="closeModal()" class="text-gray-400 hover:text-gray-600">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Type</label>
                    <select class="w-full border border-gray-200 rounded-lg p-2">
                        <option value="character">Character</option>
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Name</label>
                    <input type="text" class="w-full border border-gray-200 rounded-lg p-2">
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Description</label>
                    <textarea class="w-full border border-gray-200 rounded-lg p-2 h-32"></textarea>
                </div>
                
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Start Date</label>
                        <input type="date" class="w-full border border-gray-200 rounded-lg p-2">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">End Date</label>
                        <input type="date" class="w-full border border-gray-200 rounded-lg p-2">
                    </div>
                </div>
                
                <div class="flex justify-end space-x-3 pt-4">
                    <button onclick="closeModal()" class="btn btn-secondary">Cancel</button>
                    <button class="btn btn-primary">Add Item</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Event Creation Modal -->
    <div id="eventCreationModal" class="fixed inset-0 bg-black bg-opacity-60 hidden items-center justify-center z-50">
        <div class="bg-white rounded-xl p-6 max-w-md w-full mx-4 shadow-md-custom">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-xl font-bold text-primary">Create Timeline Event</h2>
                <button class="text-gray-400 hover:text-gray-600" id="closeEventModal">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Event Name <span class="text-error">*</span></label>
                    <input type="text" id="eventName" class="w-full px-4 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent" placeholder="Enter event name">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Time</label>
                    <input type="time" id="eventTime" class="w-full px-4 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Description</label>
                    <textarea id="eventDescription" class="w-full px-4 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent h-24" placeholder="Describe what happens in this event"></textarea>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Characters Involved</label>
                    <div id="eventCharacters" class="space-y-2 bg-gray-50 p-2 rounded-lg min-h-[50px]">
                        <!-- Characters will be listed here -->
                    </div>
                </div>
                <div class="flex justify-end space-x-3 pt-4">
                    <button id="cancelEvent" class="btn btn-secondary">Cancel</button>
                    <button id="createEvent" class="btn btn-primary">Create Event</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Event Details Panel -->
    <div id="eventDetailsPanel" class="fixed right-0 top-0 h-screen w-96 bg-white shadow-lg transform translate-x-full transition-transform duration-300 z-40">
        <div class="h-full flex flex-col">
            <div class="p-6 border-b border-gray-100">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-xl font-bold text-primary" id="eventDetailName">Event Name</h2>
                    <button class="text-gray-400 hover:text-gray-600" onclick="closeEventDetails()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="text-sm text-gray-500" id="eventDetailTime">Time: --:--</div>
            </div>
            
            <div class="flex-1 overflow-y-auto p-6">
                <div class="space-y-6">
                    <div>
                        <h3 class="text-sm font-semibold text-gray-500 uppercase tracking-wider mb-2">Description</h3>
                        <p class="text-gray-700" id="eventDetailDescription">Event description will appear here</p>
                    </div>
                    
                    <div>
                        <h3 class="text-sm font-semibold text-gray-500 uppercase tracking-wider mb-2">Characters Involved</h3>
                        <div class="space-y-2" id="eventDetailCharacters">
                            <!-- Characters will be listed here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="p-6 border-t border-gray-100">
                <button class="btn btn-primary w-full" id="editEventBtn">
                    <i class="fas fa-edit mr-2"></i>
                    Edit Event
                </button>
            </div>
        </div>
    </div>

    <!-- Location Modal -->
    <div id="locationModal" class="fixed inset-0 bg-black bg-opacity-60 hidden items-center justify-center z-50">
        <div class="bg-white rounded-xl p-6 max-w-md w-full mx-4 shadow-md-custom">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-xl font-bold text-primary">Add Location</h2>
                <button class="text-gray-400 hover:text-gray-600" id="closeLocationModal">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Location Name <span class="text-error">*</span></label>
                    <input type="text" id="locationName" class="w-full px-4 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent" placeholder="Enter location name">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Type <span class="text-error">*</span></label>
                    <select id="locationType" class="w-full px-4 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent">
                        <option value="City">City</option>
                        <option value="Country">Country</option>
                        <option value="Building">Building</option>
                        <option value="Natural Feature">Natural Feature</option>
                        <option value="Other">Other</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Description</label>
                    <textarea id="locationDescription" class="w-full px-4 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent h-24" placeholder="Describe this location"></textarea>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Key Features</label>
                    <textarea id="locationFeatures" class="w-full px-4 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent h-20" placeholder="List key features of this location"></textarea>
                </div>
                <input type="hidden" id="locationId" value="">
                <div class="flex justify-end space-x-3 pt-4">
                    <button id="cancelLocation" class="btn btn-secondary">Cancel</button>
                    <button id="createLocation" class="btn btn-primary">Add Location</button>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { supabase, auth, projects, characters, timelineEvents, settings } from './lib/supabase.js';
        
        // Variables to store the current project ID and user information
        let currentProjectId = null;
        let currentUser = null;

        // Store character relationship data for better performance
        let characterRelationships = new Map();

        document.addEventListener('DOMContentLoaded', async function() {
            // Initialize by getting the current user and project ID
            try {
                // Get current user
                const { data: { user }, error: userError } = await auth.getUser();
                if (userError) throw userError;
                
                if (!user) {
                    // Redirect to auth page if not logged in
                    window.location.href = '/auth/auth.html';
                    return;
                }
                
                currentUser = user;
                
                // Get project ID from URL or localStorage
                // First try to get from URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                const projectIdFromUrl = urlParams.get('project_id');
                
                // If not in URL, check localStorage
                const projectIdFromStorage = localStorage.getItem('currentProjectId');
                
                // Set current project ID - prioritize URL parameter
                currentProjectId = projectIdFromUrl || projectIdFromStorage;
                
                if (!currentProjectId) {
                    console.error("No project ID found. Please go back to the main page and select a project.");
                    // Could display an error message here
                    return;
                }
                
                console.log("Loaded project ID:", currentProjectId);
                
                // Store the project ID in localStorage for persistence
                localStorage.setItem('currentProjectId', currentProjectId);
                
                // Load data from Supabase
                await loadCharacters();
                await loadLocations();
                await loadTimelineEvents();
            } catch (error) {
                console.error("Error initializing context page:", error);
            }
            
            // Continue with the rest of the initialization code
            // Tab switching
            const tabButtons = document.querySelectorAll('.tab-btn');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Remove active class from all buttons
                    tabButtons.forEach(btn => {
                        btn.classList.remove('active', 'border-primary', 'text-primary');
                        btn.classList.add('border-transparent');
                    });
                    
                    // Add active class to clicked button
                    button.classList.add('active', 'border-primary', 'text-primary');
                    button.classList.remove('border-transparent');
                    
                    // Hide all tab contents
                    tabContents.forEach(content => {
                        content.classList.add('hidden');
                    });
                    
                    // Show the selected tab content
                    const tabName = button.getAttribute('data-tab');
                    document.getElementById(tabName + 'Tab').classList.remove('hidden');
                });
            });
            
            // Drag and drop functionality for timeline
            const characterItems = document.querySelectorAll('.character-item');
            const timelineCells = document.querySelectorAll('.timeline-cell');
            let draggedItem = null;
            let startX, startY;
            let originalX, originalY;
            
            // Setup drag events for character items
            characterItems.forEach(item => {
                item.addEventListener('dragstart', function(e) {
                    draggedItem = this;
                    this.classList.add('dragging');
                    
                    // Store character data
                    const charData = {
                        name: this.getAttribute('data-name'),
                        color: this.getAttribute('data-color'),
                        role: this.getAttribute('data-role')
                    };
                    e.dataTransfer.setData('text/plain', JSON.stringify(charData));
                    
                    // Store initial mouse position
                    startX = e.clientX;
                    startY = e.clientY;
                });
            });
            
            // Setup drop zone for timeline
            document.querySelector('.timeline-grid').addEventListener('dragover', function(e) {
                e.preventDefault();
                const rect = this.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Find the closest timeline cell
                const cell = findClosestTimelineCell(e.clientX, e.clientY);
                if (cell) {
                    // Remove drag-over class from all cells
                    document.querySelectorAll('.timeline-cell').forEach(c => c.classList.remove('drag-over'));
                    // Add drag-over class to target cell
                    cell.classList.add('drag-over');
                }
            });

            document.querySelector('.timeline-grid').addEventListener('dragleave', function(e) {
                // Remove drag-over class from all cells when dragging leaves the grid
                document.querySelectorAll('.timeline-cell').forEach(c => c.classList.remove('drag-over'));
            });

            document.querySelector('.timeline-grid').addEventListener('drop', function(e) {
                e.preventDefault();
                
                const cell = findClosestTimelineCell(e.clientX, e.clientY);
                if (!cell) return;

                document.querySelectorAll('.timeline-cell').forEach(c => c.classList.remove('drag-over'));

                try {
                    const charData = JSON.parse(e.dataTransfer.getData('text/plain'));
                    
                    // Check if dropping onto an existing event
                    const existingEvent = cell.querySelector('.timeline-event');
                    if (existingEvent) {
                        // Add character to existing event
                        const eventId = existingEvent.getAttribute('data-event-id');
                        addCharacterToEvent(eventId, charData);
                    } else {
                        // Create new event
                        pendingEventCell = cell;
                        pendingEventCharacters = [charData];
                        
                        // Get time value from the cell
                        const timeValue = cell.getAttribute('data-time') || "0";
                        console.log("Time value passed to modal:", timeValue);
                        showEventCreationModal(timeValue);
                    }
                } catch (error) {
                    console.error('Error handling drop:', error);
                }
            });

            // Helper function to find the closest timeline cell
            function findClosestTimelineCell(x, y) {
                const cells = document.querySelectorAll('.timeline-cell');
                let closestCell = null;
                let closestDistance = Infinity;

                cells.forEach(cell => {
                    const rect = cell.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const distance = Math.sqrt(
                        Math.pow(x - centerX, 2) + 
                        Math.pow(y - centerY, 2)
                    );

                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestCell = cell;
                    }
                });

                return closestCell;
            }

            // Add styles for drag and drop
            const style = document.createElement('style');
            style.textContent = `
                .timeline-cell {
                    position: relative;
                    min-height: 70px;
                    transition: background-color 0.2s;
                }
                
                .timeline-cell.drag-over {
                    background-color: rgba(75, 94, 170, 0.1);
                }
                
                .character-tag {
                    position: absolute;
                    min-width: 60px;
                    z-index: 10;
                    cursor: move;
                    transition: transform 0.2s;
                }
                
                .character-tag:hover {
                    transform: translateY(-2px);
                    z-index: 20;
                }
            `;
            document.head.appendChild(style);

            // Add these character tree functions
            let currentCharacterData = null;
            let networkClickPosition = { x: 0, y: 0 };

            function showCharacterDetails(node) {
                // Remove highlight from all nodes
                document.querySelectorAll('.character-node').forEach(n => {
                    n.style.boxShadow = '0 1px 3px rgba(0, 0, 0, 0.1)';
                });
                
                // Highlight the selected node
                node.style.boxShadow = '0 0 0 2px white, 0 0 0 4px var(--primary)';
                
                // Get character data from node attributes
                const panel = document.getElementById('characterDetailsPanel');
                const name = node.getAttribute('data-name');
                const role = node.getAttribute('data-role');
                const traits = node.getAttribute('data-traits');
                const backstory = node.getAttribute('data-backstory');
                const id = node.getAttribute('data-id');
                
                // Get relationship data
                let relationships = [];
                try {
                    const relationshipsJson = node.getAttribute('data-relationships');
                    if (relationshipsJson) {
                        relationships = JSON.parse(relationshipsJson);
                    }
                } catch (error) {
                    console.error("Error parsing relationships:", error);
                }
                
                // Store current character data
                currentCharacterData = {
                    id,
                    name,
                    role,
                    traits,
                    backstory,
                    relationships
                };
                
                // Update panel content
                document.getElementById('characterDetailName').textContent = name;
                
                const roleElement = document.getElementById('characterDetailRole');
                roleElement.textContent = role;
                roleElement.className = `role-badge ${role.toLowerCase()}`;
                
                document.getElementById('characterDetailTraits').textContent = traits || 'No traits specified';
                document.getElementById('characterDetailBackstory').textContent = backstory || 'No backstory available';
                
                // Update relationship section
                const relationshipsContainer = document.getElementById('characterDetailRelationships');
                if (relationshipsContainer) {
                    relationshipsContainer.innerHTML = '';
                    
                    if (relationships && relationships.length > 0) {
                        relationships.forEach(relName => {
                            // Find the related character node to get its role class
                            const relatedNode = Array.from(document.querySelectorAll('.character-node')).find(
                                n => n.getAttribute('data-name') === relName
                            );
                            
                            let roleClass = 'text-primary';
                            if (relatedNode) {
                                const relRole = relatedNode.getAttribute('data-role').toLowerCase();
                                if (relRole === 'antagonist') {
                                    roleClass = 'text-error';
                                } else if (relRole === 'supporting') {
                                    roleClass = 'text-accent';
                                }
                            }
                            
                            const relationshipEl = document.createElement('div');
                            relationshipEl.className = 'p-2 bg-gray-50 rounded flex items-center';
                            relationshipEl.innerHTML = `
                                <div class="w-2 h-2 rounded-full ${roleClass.replace('text-', 'bg-')} mr-2"></div>
                                <span class="${roleClass} font-medium">${relName}</span>
                            `;
                            
                            relationshipsContainer.appendChild(relationshipEl);
                        });
                    } else {
                        relationshipsContainer.innerHTML = '<p class="text-gray-500 text-sm italic">No relationships defined</p>';
                    }
                }
                
                // Show panel
                panel.classList.remove('translate-x-full');
            }

            function closeCharacterDetails() {
                // Remove highlight from all nodes
                document.querySelectorAll('.character-node').forEach(n => {
                    n.style.boxShadow = '0 1px 3px rgba(0, 0, 0, 0.1)';
                });
                
                // Rest of the existing function...
                const panel = document.getElementById('characterDetailsPanel');
                panel.classList.add('translate-x-full');
                currentCharacterData = null;
            }

            function refreshCharacterTree() {
                const container = document.getElementById('characterTreeContainer');
                const nodes = container.querySelectorAll('.character-node');
                
                // Add click handlers to nodes
                nodes.forEach(node => {
                    node.onclick = function(e) {
                        e.stopPropagation();
                        showCharacterDetails(this);
                    };
                });

                // Update relationship lines
                updateRelationshipLines();
            }

            function updateRelationshipLines() {
                const container = document.getElementById('characterTreeContainer');
                if (!container) return;
                
                const nodes = container.querySelectorAll('.character-node');
                
                // Remove all existing dynamic lines
                container.querySelectorAll('.character-link:not([data-static="true"])').forEach(link => link.remove());
                
                // Create a map of node positions
                const nodePositions = {};
                nodes.forEach(node => {
                    const rect = node.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();
                    
                    // Get node center position relative to container
                    const centerX = rect.left + rect.width/2 - containerRect.left;
                    const centerY = rect.top + rect.height/2 - containerRect.top;
                    
                    nodePositions[node.getAttribute('data-name')] = {
                        x: centerX,
                        y: centerY,
                        element: node
                    };
                });
                
                // Define the connections based on the reference image
                const connections = [
                    { from: "John Doe", to: "Mystery Figure" },
                    { from: "John Doe", to: "Sarah" }
                ];
                
                // Create connection lines
                connections.forEach(conn => {
                    const fromPos = nodePositions[conn.from];
                    const toPos = nodePositions[conn.to];
                    
                    if (fromPos && toPos) {
                        // Calculate line properties
                        const dx = toPos.x - fromPos.x;
                        const dy = toPos.y - fromPos.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                        
                        // Create the line element
                        const line = document.createElement('div');
                        line.className = 'character-link';
                        line.style.width = `${length}px`;
                        line.style.left = `${fromPos.x}px`;
                        line.style.top = `${fromPos.y}px`;
                        line.style.transform = `rotate(${angle}deg)`;
                        
                        // Add to container
                        container.appendChild(line);
                    }
                });
            }

            // Character Tree container click handler for adding new characters
            const characterTreeContainer = document.getElementById('characterTreeContainer');
            if (characterTreeContainer) {
                characterTreeContainer.addEventListener('click', function(e) {
                    // Only register clicks directly on the container (not on nodes)
                    if (e.target === this || e.target.classList.contains('character-tree')) {
                        // Store the click position for potential character placement
                        const rect = this.getBoundingClientRect();
                        networkClickPosition = {
                            x: e.clientX - rect.left,
                            y: e.clientY - rect.top
                        };
                        
                        // Show the interaction overlay
                        const overlay = document.getElementById('networkInteractionOverlay');
                        overlay.style.display = 'block';
                        
                        // Position the overlay interaction button near the click
                        const overlayBtn = overlay.querySelector('div');
                        overlayBtn.style.left = networkClickPosition.x + 'px';
                        overlayBtn.style.top = networkClickPosition.y + 'px';
                    }
                });
            }

            // Create character node function to display Supabase data
            function createCharacterNode(character, index, totalCount) {
                const container = document.querySelector('.character-tree');
                
                // Create the node element
                const node = document.createElement('div');
                node.className = `character-node ${character.role.toLowerCase()}`;
                
                // Set data attributes for node
                node.setAttribute('data-name', character.name);
                node.setAttribute('data-role', character.role);
                node.setAttribute('data-traits', character.traits || '');
                node.setAttribute('data-backstory', character.backstory || '');
                node.setAttribute('data-id', character.id);
                
                // If we have relationship data, add it too
                if (character.relationshipNames && character.relationshipNames.length > 0) {
                    node.setAttribute('data-relationships', JSON.stringify(character.relationshipNames));
                }
                
                // Calculate position (circular arrangement)
                const centerX = container.offsetWidth / 2;
                const centerY = container.offsetHeight / 2;
                const radius = Math.min(centerX, centerY) * 0.6;
                
                // Position based on index if totalCount > 1, otherwise center
                let posX, posY;
                if (totalCount > 1) {
                    const angle = (index / totalCount) * Math.PI * 2;
                    posX = centerX + radius * Math.cos(angle);
                    posY = centerY + radius * Math.sin(angle);
                } else {
                    posX = centerX;
                    posY = centerY;
                }
                
                // Apply position
                node.style.left = `${posX}px`;
                node.style.top = `${posY}px`;
                
                // Add the display name (just the first name for display)
                const nameDisplay = character.name.split(' ')[0]; // Just first name for display
                node.innerHTML = `<div class="font-medium text-center">${nameDisplay}</div>`;
                
                // Add click handler for showing details
                node.addEventListener('click', function(e) {
                    e.stopPropagation();
                    showCharacterDetails(this);
                });
                
                // Add to container
                container.appendChild(node);
                
                return node;
            }

            // Add Character from Network button click handler
            const addCharacterFromNetworkBtn = document.getElementById('addCharacterFromNetworkBtn');
            if (addCharacterFromNetworkBtn) {
                addCharacterFromNetworkBtn.addEventListener('click', function() {
                    // Hide the overlay
                    document.getElementById('networkInteractionOverlay').style.display = 'none';
                    
                    // Open the modal for new character
                    openModal('character', {
                        posX: networkClickPosition.x,
                        posY: networkClickPosition.y
                    });
                });
            }

            // Add a function to create a new character in Supabase
            async function createCharacter(name, role, description) {
                try {
                    // Extract traits and description if they were provided
                    const descLines = description.split('\n');
                    let traits = '';
                    let backstory = '';
                    
                    descLines.forEach(line => {
                        if (line.startsWith('Traits:')) {
                            traits = line.replace('Traits:', '').trim();
                        } else if (line.startsWith('Backstory:')) {
                            backstory = line.replace('Backstory:', '').trim();
                        } else {
                            // Append to backstory if it doesn't match patterns
                            backstory += (backstory ? '\n' : '') + line;
                        }
                    });
                    
                    // Create character in Supabase
                    const { data, error } = await characters.create(
                        currentProjectId,
                        name,
                        role,
                        traits,
                        backstory
                    );
                    
                    if (error) throw error;
                    
                    console.log("Character created:", data);
                    
                    // Reload characters to update the view
                    await loadCharacters();
                    
                    return data;
                } catch (error) {
                    console.error("Error creating character:", error);
                    alert("Error creating character: " + error.message);
                    return null;
                }
            }

            // Update the add character form submission
            const addItemForm = document.getElementById('addItemForm');
            if (addItemForm) {
                addItemForm.addEventListener('submit', async function(e) {
                    e.preventDefault();
                    
                    const nameInput = document.getElementById('itemName');
                    const typeSelect = document.getElementById('itemType');
                    const descriptionTextarea = document.getElementById('itemDescription');
                    
                    const name = nameInput.value.trim();
                    const type = typeSelect.value;
                    const description = descriptionTextarea.value.trim();
                    
                    if (!name) {
                        alert('Please enter a name');
                        return;
                    }
                    
                    // Close the modal
                    closeModal();
                    
                    // Create the item based on type
                    if (type === 'Protagonist' || type === 'Antagonist' || type === 'Supporting') {
                        // Create character
                        await createCharacter(name, type, description);
                    }
                });
            }

            // Initialize character tree
            refreshCharacterTree();
            
            // Hide network overlay when clicking anywhere else
            document.addEventListener('click', function(e) {
                const overlay = document.getElementById('networkInteractionOverlay');
                if (overlay && !e.target.closest('#characterTreeContainer')) {
                    overlay.style.display = 'none';
                }
                
                // Close character details panel when clicking outside
                const panel = document.getElementById('characterDetailsPanel');
                const characterNodes = document.querySelectorAll('.character-node');
                
                if (panel && !panel.contains(e.target) && 
                    !Array.from(characterNodes).some(node => node.contains(e.target))) {
                    closeCharacterDetails();
                }
            });

            // Add openModal function definition
            window.openModal = function(type, data = null) {
                const modal = document.getElementById('addItemModal');
                const titleElement = modal.querySelector('h2');
                const typeSelectElement = modal.querySelector('select');
                const nameInput = modal.querySelector('input[type="text"]');
                const descriptionTextarea = modal.querySelector('textarea');
                
                if (type === 'character') {
                    titleElement.textContent = data ? 'Edit Character' : 'Add New Character';
                    
                    if (data) {
                        // Pre-fill with character data
                        if (data.name) {
                            nameInput.value = data.name;
                        }
                        
                        if (data.traits || data.backstory) {
                            let description = '';
                            if (data.traits) description += `Traits: ${data.traits}\n`;
                            if (data.backstory) description += `Backstory: ${data.backstory}`;
                            descriptionTextarea.value = description.trim();
                        }
                    }
                }
                
                // Show the modal
                modal.classList.remove('hidden');
            };
            
            // Ensure closeModal is also defined in the global scope
            window.closeModal = function() {
                const modal = document.getElementById('addItemModal');
                modal.classList.add('hidden');
                
                // Reset form fields
                modal.querySelectorAll('input[type="text"], textarea').forEach(input => {
                    input.value = '';
                });
            };
            
            // Make sure other functions are available globally if needed
            window.showCharacterDetails = showCharacterDetails;
            window.closeCharacterDetails = closeCharacterDetails;
            window.refreshCharacterTree = refreshCharacterTree;
            window.updateRelationshipLines = updateRelationshipLines;

            // Fix edit button event listener
            const editCharacterBtn = document.getElementById('editCharacterBtn');
            if (editCharacterBtn) {
                editCharacterBtn.addEventListener('click', function() {
                    if (currentCharacterData) {
                        openModal('character', currentCharacterData);
                    }
                });
            }

            // Add these new functions and event handlers after the existing code
            let currentEventData = null;
            let pendingEventCell = null;
            let pendingEventCharacters = [];

            function showEventCreationModal(time) {
                const modal = document.getElementById('eventCreationModal');
                const timeInput = document.getElementById('eventTime');
                const charactersContainer = document.getElementById('eventCharacters');

                // Reset form state first
                document.getElementById('eventName').value = '';
                document.getElementById('eventDescription').value = '';
                document.querySelector('#eventCreationModal h2').textContent = 'Create Timeline Event';
                document.getElementById('createEvent').textContent = 'Create Event';

                // Set default time from cell - ensure we have a valid format
                const hourValue = parseInt(time) || 0;
                timeInput.value = hourValue.toString().padStart(2, '0') + ':00';

                // Display initial characters
                charactersContainer.innerHTML = pendingEventCharacters.map(char => `
                    <div class="flex items-center justify-between p-2 bg-white rounded">
                        <span class="flex items-center">
                            <div class="w-2 h-2 rounded-full ${getCharacterColorClass(char.role)} mr-2"></div>
                            ${char.name}
                        </span>
                        <button class="text-error hover:text-opacity-80" onclick="removeCharacterFromPending('${char.name}')">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `).join('');

                // Show the modal
                modal.classList.remove('hidden');
                modal.classList.add('flex');
                document.getElementById('eventName').focus();
            }

            // Create a timeline event element
            function createTimelineEvent(cell, eventData) {
                if (!cell || !eventData) {
                    console.error("Missing cell or event data");
                    return;
                }

                // Create event HTML
                const eventElement = document.createElement('div');
                eventElement.className = 'timeline-event bg-white rounded shadow-sm-custom p-2 text-sm';
                eventElement.setAttribute('data-event-id', eventData.id);
                eventElement.setAttribute('data-time', eventData.time);
                eventElement.setAttribute('data-description', eventData.description || '');
                eventElement.setAttribute('data-characters', JSON.stringify(eventData.characters || []));

                // Event content
                eventElement.innerHTML = `
                    <div class="font-medium">${eventData.name}</div>
                    ${eventData.characters && eventData.characters.length > 0 ? 
                        `<div class="flex flex-wrap gap-1 mt-1">
                            ${eventData.characters.slice(0, 3).map(char => 
                                `<div class="w-2 h-2 rounded-full ${getCharacterColorClass(char.role)}"></div>`
                            ).join('')}
                            ${eventData.characters.length > 3 ? `<span class="text-xs">+${eventData.characters.length - 3}</span>` : ''}
                        </div>` 
                    : ''}
                `;

                // Add click handler
                eventElement.addEventListener('click', function(e) {
                    e.stopPropagation();
                    showEventDetails(e);
                });

                // Add to cell
                cell.appendChild(eventElement);

                return eventElement;
            }

            function handleEventDrop(e) {
                e.preventDefault();
                e.stopPropagation();

                try {
                    const charData = JSON.parse(e.dataTransfer.getData('text/plain'));
                    const eventId = this.getAttribute('data-event-id');
                    addCharacterToEvent(eventId, charData);
                } catch (error) {
                    console.error('Error adding character to event:', error);
                }
            }

            function addCharacterToEvent(eventId, charData) {
                const eventElement = document.querySelector(`[data-event-id="${eventId}"]`);
                if (!eventElement) return;

                const characters = JSON.parse(eventElement.getAttribute('data-characters') || '[]');
                if (!characters.some(c => c.name === charData.name)) {
                    characters.push(charData);
                    eventElement.setAttribute('data-characters', JSON.stringify(characters));
                    
                    // If the event details panel is open and showing this event, update it
                    if (currentEventData && currentEventData.id === eventId) {
                        updateEventDetailsCharacters(characters);
                    }
                }
            }

            function showEventDetails(e) {
                const eventElement = e.currentTarget;
                const panel = document.getElementById('eventDetailsPanel');
                
                currentEventData = {
                    id: eventElement.getAttribute('data-event-id'),
                    name: eventElement.textContent,
                    time: eventElement.getAttribute('data-time'),
                    description: eventElement.getAttribute('data-description'),
                    characters: JSON.parse(eventElement.getAttribute('data-characters') || '[]')
                };

                document.getElementById('eventDetailName').textContent = currentEventData.name;
                document.getElementById('eventDetailTime').textContent = `Time: ${currentEventData.time}`;
                document.getElementById('eventDetailDescription').textContent = currentEventData.description;
                
                updateEventDetailsCharacters(currentEventData.characters);
                
                panel.classList.remove('translate-x-full');
            }

            function updateEventDetailsCharacters(characters) {
                const container = document.getElementById('eventDetailCharacters');
                container.innerHTML = characters.map(char => `
                    <div class="flex items-center justify-between p-2 bg-gray-50 rounded">
                        <span class="flex items-center">
                            <div class="w-2 h-2 rounded-full ${getCharacterColorClass(char.role)} mr-2"></div>
                            ${char.name}
                        </span>
                        <button class="text-error hover:text-opacity-80" onclick="removeCharacterFromEvent('${currentEventData.id}', '${char.name}')">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `).join('');
            }

            function closeEventDetails() {
                document.getElementById('eventDetailsPanel').classList.add('translate-x-full');
                // Don't clear currentEventData here, as it might be needed for editing
                // Only clear it when we're done editing, in resetEventModalAndState
            }

            function getCharacterColorClass(role) {
                switch (role) {
                    case 'Antagonist': return 'bg-error';
                    case 'Supporting': return 'bg-accent';
                    case 'Minor': return 'bg-secondary';
                    default: return 'bg-primary';
                }
            }

            // Event Creation Modal Handlers
            document.getElementById('closeEventModal').addEventListener('click', () => {
                document.getElementById('eventCreationModal').classList.add('hidden');
                pendingEventCell = null;
                pendingEventCharacters = [];
            });

            document.getElementById('cancelEvent').addEventListener('click', () => {
                document.getElementById('eventCreationModal').classList.add('hidden');
                pendingEventCell = null;
                pendingEventCharacters = [];
            });

            // Add these styles to the existing style element
            style.textContent += `
                .timeline-event {
                    position: absolute;
                    min-width: 60px;
                    z-index: 10;
                    left: 50%;
                    top: 50%;
                    transform: translate(-50%, -50%);
                    transition: all 0.2s ease;
                }
                
                .timeline-event:hover {
                    transform: translate(-50%, -50%) translateY(-2px);
                    z-index: 20;
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                }
            `;

            // Make event-related functions globally available
            window.closeEventDetails = closeEventDetails;

            window.removeCharacterFromEvent = function(eventId, characterName) {
                const eventElement = document.querySelector(`[data-event-id="${eventId}"]`);
                if (!eventElement) return;

                const characters = JSON.parse(eventElement.getAttribute('data-characters') || '[]');
                const updatedCharacters = characters.filter(char => char.name !== characterName);
                eventElement.setAttribute('data-characters', JSON.stringify(updatedCharacters));

                if (currentEventData && currentEventData.id === eventId) {
                    updateEventDetailsCharacters(updatedCharacters);
                }
            };

            window.removeCharacterFromPending = function(characterName) {
                pendingEventCharacters = pendingEventCharacters.filter(char => char.name !== characterName);
                const charactersContainer = document.getElementById('eventCharacters');
                charactersContainer.innerHTML = pendingEventCharacters.map(char => `
                    <div class="flex items-center justify-between p-2 bg-white rounded">
                        <span class="flex items-center">
                            <div class="w-2 h-2 rounded-full ${getCharacterColorClass(char.role)} mr-2"></div>
                            ${char.name}
                        </span>
                        <button class="text-error hover:text-opacity-80" onclick="removeCharacterFromPending('${char.name}')">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `).join('');
            };

            // Edit Event button click handler
            document.getElementById('editEventBtn').addEventListener('click', () => {
                // Store current event data in a separate variable to prevent it from being lost
                const eventDataToEdit = {...currentEventData};
                
                if (!eventDataToEdit || !eventDataToEdit.id) {
                    console.error("Error: No valid event selected for editing");
                    alert("No valid event selected for editing. Please try again.");
                    return;
                }
                
                // Preserve the event data in a more persistent location before closing the details panel
                window.eventDataForEditing = eventDataToEdit;
                
                editEvent(eventDataToEdit);
            });

            // Add editEvent function to make the edit button work
            window.editEvent = function(eventDataToEdit) {
                // Use the event data that was passed in or retrieve from the window object
                // This ensures we don't lose the data between function calls
                let dataToEdit = eventDataToEdit || window.eventDataForEditing;
                
                if (!dataToEdit) {
                    console.error("Error: No event data available for editing");
                    alert("Error: No event data available for editing. Please try selecting an event first.");
                    return;
                }
                
                // Store in currentEventData for later use in the update process
                currentEventData = dataToEdit;
                
                // Log the event data we're working with to debug
                console.log("Editing event with data:", currentEventData);
                
                // Populate the event creation modal with current event data
                document.getElementById('eventName').value = currentEventData.name || '';
                document.getElementById('eventTime').value = currentEventData.time || '';
                document.getElementById('eventDescription').value = currentEventData.description || '';
                pendingEventCharacters = Array.isArray(currentEventData.characters) ? [...currentEventData.characters] : [];
                
                // Update characters list in the modal
                const charactersContainer = document.getElementById('eventCharacters');
                charactersContainer.innerHTML = pendingEventCharacters.map(char => `
                    <div class="flex items-center justify-between p-2 bg-white rounded">
                        <span class="flex items-center">
                            <div class="w-2 h-2 rounded-full ${getCharacterColorClass(char.role)} mr-2"></div>
                            ${char.name}
                        </span>
                        <button class="text-error hover:text-opacity-80" onclick="removeCharacterFromPending('${char.name}')">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `).join('');
                
                // Update the modal title and button
                document.querySelector('#eventCreationModal h2').textContent = 'Edit Timeline Event';
                document.getElementById('createEvent').textContent = 'Update Event';
                
                // Store the event element for updating - add null check
                const eventElement = currentEventData.id ? document.querySelector(`[data-event-id="${currentEventData.id}"]`) : null;
                if (eventElement && eventElement.parentNode) {
                    pendingEventCell = eventElement.parentNode;
                } else {
                    console.error("Error: Could not find event element or its parent");
                    // Try to find a cell to place the event if original location is lost
                    const hourMatch = currentEventData.time ? currentEventData.time.match(/^(\d{1,2}):/) : null;
                    const hour = hourMatch ? parseInt(hourMatch[1]) : 0;
                    pendingEventCell = document.querySelector(`.timeline-cell[data-time="${hour}"]`);
                    
                    if (!pendingEventCell) {
                        // As a last resort, just use the first timeline cell
                        pendingEventCell = document.querySelector('.timeline-cell');
                        console.log("Using fallback cell for event placement");
                    }
                }
                
                // Show the modal
                document.getElementById('eventCreationModal').classList.remove('hidden');
                document.getElementById('eventCreationModal').classList.add('flex');
                
                // Close the details panel
                closeEventDetails();
            };

            // Add a clean implementation of the createEvent button handler
            document.getElementById('createEvent').addEventListener('click', async function() {
                const name = document.getElementById('eventName').value.trim();
                const time = document.getElementById('eventTime').value;
                const description = document.getElementById('eventDescription').value.trim();

                if (!name) {
                    alert('Please enter an event name');
                    return;
                }

                if (!pendingEventCell) {
                    console.error("No target cell found for the event");
                            return;
                        }
                        
                try {
                    // Get location information from the cell
                    const locationName = pendingEventCell.getAttribute('data-location') || 'Castle';
                    const locationId = pendingEventCell.getAttribute('data-location-id');
                    
                    // Prepare character data for storage
                    const characterData = JSON.stringify(pendingEventCharacters || []);
                    
                    // Determine if we're updating or creating
                    if (currentEventData && currentEventData.id && !currentEventData.id.startsWith('temp-')) {
                        // Update existing event
                        const updates = {
                                name: name,
                                date_time: time,
                                description: description,
                            characters: characterData,
                            location: locationName
                        };
                        
                        if (locationId) {
                            updates.location_id = locationId;
                        }
                        
                        const { data, error } = await timelineEvents.update(currentEventData.id, updates);
                            
                        if (error) throw error;
                        
                        console.log("Event updated:", data);
                        
                        // Find and remove old event element
                        const oldEvent = document.querySelector(`[data-event-id="${currentEventData.id}"]`);
                        if (oldEvent) oldEvent.remove();
                        
                        // Create updated event in UI
                        createTimelineEvent(pendingEventCell, {
                            id: currentEventData.id,
                                name: name,
                                time: time,
                                description: description,
                            characters: pendingEventCharacters || []
                            });
                    } else {
                        // Create new event
                        const { data, error } = await timelineEvents.create(
                            currentProjectId,
                            name,
                            time,
                            description,
                            "" // significance (not used in UI)
                        );
                            
                        if (error) throw error;
                        
                        console.log("Event created:", data);
                        
                        // Create new event in UI
                        if (data && data.length > 0) {
                            createTimelineEvent(pendingEventCell, {
                                id: data[0].id,
                                name: name,
                                time: time,
                                description: description,
                                characters: pendingEventCharacters || []
                            });
                        }
                    }

                    // Reset state and close modal
                    resetEventModalAndState();
                } catch (error) {
                    console.error("Error saving event:", error);
                    alert(`Error saving event: ${error.message}`);
                }
            });

            // Implementation for loading character relationships from Supabase
            async function loadCharacterRelationships(characterData) {
                try {
                    // Clear existing relationship data
                    characterRelationships.clear();
                    
                    // Initialize relationship arrays for each character
                    characterData.forEach(char => {
                        characterRelationships.set(char.id, []);
                    });
                    
                    // Fetch all character relationships for this project
                    const { data: relationships, error } = await supabase
                        .from('character_relationships')
                        .select('*, character_id, related_character_id')
                        .in('character_id', characterData.map(c => c.id));
                    
                    if (error) {
                        console.error("Error loading character relationships:", error);
                        return characterRelationships;
                    }
                    
                    if (relationships && relationships.length > 0) {
                        // Process each relationship
                        relationships.forEach(rel => {
                            const charId = rel.character_id;
                            const relatedId = rel.related_character_id;
                            
                            // Add to the character's relationships array
                            if (characterRelationships.has(charId)) {
                                characterRelationships.get(charId).push({
                                    id: rel.id,
                                    relatedCharacterId: relatedId,
                                    relationshipType: rel.relationship_type || 'connected'
                                });
                            }
                        });
                    }
                    
                    // Store relationship data on character nodes
                    characterData.forEach(char => {
                        const rels = characterRelationships.get(char.id) || [];
                        char.relationships = rels;
                        
                        // Get related character names for display
                        char.relationshipNames = rels.map(r => {
                            const relatedChar = characterData.find(c => c.id === r.relatedCharacterId);
                            return relatedChar ? relatedChar.name : null;
                        }).filter(Boolean);
                    });
                    
                    // Update node positions based on relationships
                    setTimeout(() => {
                        updateCharacterNodePositions();
                        updateRelationshipLines();
                    }, 200);
                    
                    return characterRelationships;
                } catch (error) {
                    console.error("Error in loadCharacterRelationships:", error);
                    return new Map();
                }
            }

            // Implementation of createCharacterRelationship function
            async function createCharacterRelationship(characterId, relatedCharacterId, relationshipType = 'connected') {
                try {
                    // Create the relationship in Supabase
                    const { data, error } = await characters.createRelationship(
                        characterId,
                        relatedCharacterId,
                        relationshipType
                    );
                    
                    if (error) throw error;
                    
                    console.log("Character relationship created:", data);
                    
                    // Reload characters to update the view
                    await loadCharacters();
                    
                    return data;
                } catch (error) {
                    console.error("Error creating character relationship:", error);
                    alert("Error creating relationship: " + error.message);
                    return null;
                }
            }
            
            // Implementation of deleteCharacterRelationship function
            async function deleteCharacterRelationship(relationshipId) {
                try {
                    // Delete the relationship from Supabase
                    const { error } = await characters.deleteRelationship(relationshipId);
                        
                    if (error) throw error;
                    
                    console.log("Character relationship deleted:", relationshipId);
                    
                    // Reload characters to update the view
                    await loadCharacters();
                    
                    return true;
                } catch (error) {
                    console.error("Error deleting character relationship:", error);
                    alert("Error deleting relationship: " + error.message);
                    return false;
                }
            }

            // Implementation of loadLocations function
            async function loadLocations() {
                try {
                    if (!currentProjectId) return;
                    
                    // Fetch locations from Supabase
                    const { data: locations, error } = await settings.getByProject(currentProjectId);
                    
                    if (error) {
                        console.error("Error loading locations:", error);
                        return;
                    }
                    
                    if (!locations || locations.length === 0) {
                        console.log("No locations found for this project");
                        return;
                    }
                    
                    console.log("Loaded locations:", locations);
                    
                    // Get the timeline table body
                    const tableBody = document.querySelector('.timeline-grid tbody');
                    if (!tableBody) return;
                    
                    // Clear existing locations
                    tableBody.innerHTML = '';
                    
                    // Filter locations to show only those that are suitable for timeline
                    const timelineLocations = locations.filter(loc => 
                        loc.type === 'Building' || 
                        loc.type === 'City' || 
                        loc.type === 'Country' || 
                        loc.type === 'Natural Feature' ||
                        loc.type === 'Other');
                    
                    // Add locations to timeline table
                    timelineLocations.forEach(location => {
                        const row = document.createElement('tr');
                        
                        // Add location name cell
                        const nameCell = document.createElement('td');
                        nameCell.className = 'border-r border-b border-gray-200 p-3 font-medium';
                        nameCell.textContent = location.name;
                        row.appendChild(nameCell);
                        
                        // Add 24 time cells
                        for (let hour = 0; hour < 24; hour++) {
                            const cell = document.createElement('td');
                            cell.className = hour < 23 ? 'border-r border-b border-gray-200 timeline-cell relative' : 'border-b border-gray-200 timeline-cell relative';
                            cell.setAttribute('data-time', hour);
                            cell.setAttribute('data-location', location.name);
                            cell.setAttribute('data-location-id', location.id);
                            row.appendChild(cell);
                    }
                    
                        tableBody.appendChild(row);
                    });
                    
                    // If no locations added yet, add a default "Castle" row
                    if (timelineLocations.length === 0) {
                        const row = document.createElement('tr');
                        
                        // Add default location name cell
                        const nameCell = document.createElement('td');
                        nameCell.className = 'border-r border-b border-gray-200 p-3 font-medium';
                        nameCell.textContent = 'Castle';
                        row.appendChild(nameCell);
                        
                        // Add 24 time cells
                        for (let hour = 0; hour < 24; hour++) {
                            const cell = document.createElement('td');
                            cell.className = hour < 23 ? 'border-r border-b border-gray-200 timeline-cell relative' : 'border-b border-gray-200 timeline-cell relative';
                            cell.setAttribute('data-time', hour);
                            cell.setAttribute('data-location', 'Castle');
                            row.appendChild(cell);
                        }
                        
                        tableBody.appendChild(row);
                    }
                } catch (error) {
                    console.error("Error in loadLocations:", error);
                }
            }

            // Implementation of loadTimelineEvents function
            async function loadTimelineEvents() {
                try {
                    if (!currentProjectId) return;
                    
                    // Fetch timeline events from Supabase
                    const { data: events, error } = await timelineEvents.getByProject(currentProjectId);
                    
                    if (error) {
                        console.error("Error loading timeline events:", error);
                        return;
                    }
                    
                    if (!events || events.length === 0) {
                        console.log("No timeline events found for this project");
                        return;
                    }
                    
                    console.log("Loaded timeline events:", events);
                    
                    // Process each event
                    events.forEach(event => {
                        // Extract hour from the date_time
                        let hour = 0;
                        if (event.date_time) {
                            const timeMatch = event.date_time.match(/^(\d{1,2}):/);
                            hour = timeMatch ? parseInt(timeMatch[1]) : 0;
                        }
                        
                        // Find the correct cell to place the event
                        const locationName = event.location || 'Castle'; // Default to Castle if no location
                        const cell = document.querySelector(`.timeline-cell[data-time="${hour}"][data-location="${locationName}"]`);
                        
                        if (cell) {
                            // Create the event element with proper data
                            const eventData = {
                                id: event.id,
                                name: event.name,
                                time: event.date_time || `${hour}:00`,
                                description: event.description || '',
                                characters: JSON.parse(event.characters || '[]')
                            };
                            
                            // Add the event to the cell
                            createTimelineEvent(cell, eventData);
                        }
                    });
                    
                    // Setup event listeners for all events
                    setupTimelineEventListeners();
                } catch (error) {
                    console.error("Error in loadTimelineEvents:", error);
                }
            }

            // Implementation of createLocation function
            async function createLocation(name, type, description, keyFeatures) {
                try {
                    // Create the location in Supabase
                    const { data, error } = await settings.create(
                        currentProjectId,
                        name,
                        type,
                        description,
                        keyFeatures
                    );
                    
                    if (error) throw error;
                    
                    console.log("Location created:", data);
                    
                    // Reload the locations to update the view
                    await loadLocations();
                    
                    return data;
                } catch (error) {
                    console.error("Error creating location:", error);
                    alert("Error creating location: " + error.message);
                    return null;
                }
            }

            // Implementation of updateLocation function
            async function updateLocation(id, name, type, description, keyFeatures) {
                try {
                    // Create the updates object
                    const updates = {
                        name,
                        type,
                        description,
                        key_features: keyFeatures
                    };
                    
                    // Update the location in Supabase
                    const { data, error } = await settings.update(id, updates);
                    
                    if (error) throw error;
                    
                    console.log("Location updated:", data);
                    
                    // Reload the locations to update the view
                    await loadLocations();
                    
                    return data;
                } catch (error) {
                    console.error("Error updating location:", error);
                    alert("Error updating location: " + error.message);
                    return null;
                }
            }

            // Implementation of deleteLocation function
            async function deleteLocation(id) {
                try {
                    // Delete the location from Supabase
                    const { error } = await settings.delete(id);
                    
                    if (error) throw error;
                    
                    console.log("Location deleted:", id);
                    
                    // Reload the locations to update the view
                    await loadLocations();
                    
                    return true;
                } catch (error) {
                    console.error("Error deleting location:", error);
                    alert("Error deleting location: " + error.message);
                    return false;
                }
            }
            
            // Make the functions available in the global scope
            window.loadCharacters = loadCharacters;
            window.loadLocations = loadLocations;
            window.loadTimelineEvents = loadTimelineEvents;
            window.createLocation = createLocation;
            window.updateLocation = updateLocation;
            window.deleteLocation = deleteLocation;
            window.createCharacterRelationship = createCharacterRelationship;
            window.deleteCharacterRelationship = deleteCharacterRelationship;

            // Initialize relationship selection elements
            const newRelationshipSelect = document.getElementById('newRelationshipSelect');
            const relationshipList = document.getElementById('relationshipList');
            const addRelationshipBtn = document.getElementById('addRelationshipBtn');
            
            // Add relationship button click handler
            if (addRelationshipBtn) {
                addRelationshipBtn.addEventListener('click', function() {
                    addRelationship();
                });
            }
            
            // Add relationship with Enter key press
            if (newRelationshipSelect) {
                newRelationshipSelect.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        addRelationship();
                    }
                });
            }

            // Update addRelationship function to persist to database
            window.addRelationship = async function() {
                if (!newRelationshipSelect || !relationshipList) {
                    console.error("Relationship elements not found");
                    return;
                }
                
                const selectedOption = newRelationshipSelect.options[newRelationshipSelect.selectedIndex];
                if (!selectedOption || !selectedOption.value) {
                    return; // Nothing selected
                }
                
                const relatedCharacterId = selectedOption.value;
                const relatedCharacterName = selectedOption.textContent.split(' (')[0];
                const relatedCharacterRole = selectedOption.textContent.split('(')[1]?.replace(')', '') || '';
                
                if (!currentlyEditing || !currentlyEditing.id) {
                    console.error("No character is currently being edited");
                    return;
                }
                
                // Check if relationship already exists in the UI
                const existingRelationships = relationshipList.querySelectorAll('span');
                for (let i = 0; i < existingRelationships.length; i++) {
                    if (existingRelationships[i].textContent.includes(relatedCharacterName)) {
                        return; // Relationship already exists
                    }
                }
                
                try {
                    // Create relationship in Supabase
                    const { data, error } = await createCharacterRelationship(
                        currentlyEditing.id,
                        relatedCharacterId,
                        'connected'  // Default relationship type
                    );
                    
                    if (error) {
                        console.error("Error creating relationship:", error);
                        alert("Failed to create relationship: " + error.message);
                        return;
                    }
                    
                    // Determine color based on character role
                    let colorClass = 'bg-primary'; // default
                    if (relatedCharacterRole.includes('Antagonist')) {
                        colorClass = 'bg-error';
                    } else if (relatedCharacterRole.includes('Supporting')) {
                        colorClass = 'bg-accent';
                    } else if (relatedCharacterRole.includes('Minor')) {
                        colorClass = 'bg-secondary';
                    }
                    
                    // Create relationship element
                    const relationshipEl = document.createElement('div');
                    relationshipEl.className = 'flex items-center justify-between text-sm';
                    relationshipEl.innerHTML = `
                        <div class="flex items-center">
                            <div class="w-2 h-2 rounded-full ${colorClass} mr-2"></div>
                            <span>${relatedCharacterName} (${relatedCharacterRole})</span>
                        </div>
                        <button class="text-error hover:text-opacity-80 relationship-delete-btn" data-id="${data.id}">
                            <i class="fas fa-times"></i>
                        </button>
                    `;
                    
                    // Add to list
                    relationshipList.appendChild(relationshipEl);
                    
                    // Add delete handler
                    const deleteBtn = relationshipEl.querySelector('.relationship-delete-btn');
                    deleteBtn.addEventListener('click', async function() {
                        const relationshipId = this.getAttribute('data-id');
                        await deleteCharacterRelationship(relationshipId);
                        this.closest('div.flex.items-center.justify-between').remove();
            });
            
                    // Reset select
                    newRelationshipSelect.value = '';
                } catch (error) {
                    console.error("Error in addRelationship:", error);
                    alert("Failed to add relationship: " + error.message);
                }
            };

            // Function to update relationship select options
            function updateRelationshipSelect() {
                if (!newRelationshipSelect || !currentlyEditing) return;
                
                // Clear existing options except first "Select a character..." option
                while (newRelationshipSelect.options.length > 1) {
                    newRelationshipSelect.remove(1);
                }
                
                // Add all character nodes as options, excluding the currently editing character
                document.querySelectorAll('.character-node').forEach(node => {
                    const name = node.getAttribute('data-name');
                    const role = node.getAttribute('data-role');
                    const id = node.getAttribute('data-id');
                    
                    // Skip if this is the currently editing character
                    if (currentlyEditing && (currentlyEditing.id === id || currentlyEditing.name === name)) {
                        return;
                    }
                    
                    // Check if this relationship already exists in the UI
                    let alreadyRelated = false;
                    if (relationshipList) {
                        const existingRelationships = relationshipList.querySelectorAll('span');
                        for (let i = 0; i < existingRelationships.length; i++) {
                            if (existingRelationships[i].textContent.includes(name)) {
                                alreadyRelated = true;
                                break;
                            }
                        }
                    }
                    
                    // Skip if already related
                    if (alreadyRelated) return;
                    
                    // Add option to dropdown
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = `${name} (${role})`;
                    newRelationshipSelect.appendChild(option);
                });
            }

            // Make the functions available globally
            window.updateRelationshipSelect = updateRelationshipSelect;

            // Event handlers for character form buttons
            if (newCharacterBtn) {
                newCharacterBtn.addEventListener('click', showNewCharacterForm);
            }

            if (cancelCharacterBtn) {
                cancelCharacterBtn.addEventListener('click', () => {
                    characterFormContainer.classList.add('hidden');
                    currentlyEditing = null;
                });
            }

            if (saveCharacterBtn) {
                saveCharacterBtn.addEventListener('click', async function() {
                    // Basic validation
                    let isValid = true;
                    
                    const name = document.getElementById('protagonistName').value;
                    const role = document.getElementById('protagonistRole').value;
                
                if (!name) {
                        document.getElementById('protagonistName').classList.add('border-error');
                        isValid = false;
                    } else {
                        document.getElementById('protagonistName').classList.remove('border-error');
                    }
                    
                    if (isValid) {
                        const traits = document.getElementById('protagonistTraits').value;
                        const backstory = document.getElementById('protagonistBackstory').value;
                        
                        try {
                            if (currentlyEditing && currentlyEditing.id) {
                                // Update existing character
                                const { data, error } = await characters.update(
                                    currentlyEditing.id, 
                                    {
                                        name,
                                        role,
                                        traits,
                                        backstory
                                    }
                                );
                                
                                if (error) throw error;
                                
                                console.log('Updated character:', data);
                                
                                // Reload characters to update the view
                                await loadCharacters();
                } else {
                                // Create new character
                                const { data, error } = await characters.create(
                                    currentProjectId,
                                    name,
                                    role,
                                    traits,
                                    backstory
                                );
                                
                                if (error) throw error;
                                
                                console.log('Created new character:', data);
                                
                                // Reload characters to update the view
                                await loadCharacters();
                }
                            
                            // Hide the form
                            characterFormContainer.classList.add('hidden');
                            
                            // Reset editing state
                            currentlyEditing = null;
                            
                            // Reset form
                            resetCharacterForm();
                        } catch (error) {
                            console.error("Error saving character:", error);
                            alert("Error saving character: " + error.message);
                        }
                    }
                });
            }

            // Helper function to reset the event modal and state
            function resetEventModalAndState() {
                document.getElementById('eventName').value = '';
                document.getElementById('eventTime').value = '';
                document.getElementById('eventDescription').value = '';
                
                const modal = document.getElementById('eventCreationModal');
                if (modal) {
                    modal.classList.add('hidden');
                    modal.classList.remove('flex');
                }
                
                const title = document.querySelector('#eventCreationModal h2');
                if (title) {
                    title.textContent = 'Create Timeline Event';
                }
                
                const button = document.getElementById('createEvent');
                if (button) {
                    button.textContent = 'Create Event';
                }
                
                // Clear event character list
                const charactersList = document.getElementById('eventCharacters');
                if (charactersList) {
                    charactersList.innerHTML = '';
                }
                
                // Reset state variables
                pendingEventCell = null;
                pendingEventCharacters = [];
                currentEventData = null;
                window.eventDataForEditing = null;
                }
                
            // Make these functions globally available
            window.resetEventModalAndState = resetEventModalAndState;
            window.getCharacterColorClass = getCharacterColorClass;

            // Update character node positions after loading relationships
            function updateCharacterNodePositions() {
                const container = document.getElementById('characterTreeContainer');
                if (!container) return;
                
                const nodes = container.querySelectorAll('.character-node');
                if (nodes.length === 0) return;
                
                // Calculate central position
                const containerWidth = container.offsetWidth;
                const containerHeight = container.offsetHeight;
                const centerX = containerWidth / 2;
                const centerY = containerHeight / 2;
                
                // Group nodes by role
                const protagonists = [];
                const antagonists = [];
                const supporting = [];
                const others = [];
                
                nodes.forEach(node => {
                    const role = node.getAttribute('data-role').toLowerCase();
                    if (role === 'protagonist') {
                        protagonists.push(node);
                    } else if (role === 'antagonist') {
                        antagonists.push(node);
                    } else if (role === 'supporting') {
                        supporting.push(node);
                    } else {
                        others.push(node);
                    }
                });
                
                // Position protagonists in the center
                const radius = Math.min(containerWidth, containerHeight) * 0.3;
                
                // Place protagonists in center
                protagonists.forEach((node, i) => {
                    const angle = (i / protagonists.length) * Math.PI * 2;
                    const x = centerX + (radius * 0.5) * Math.cos(angle);
                    const y = centerY + (radius * 0.5) * Math.sin(angle);
                    node.style.left = `${x}px`;
                    node.style.top = `${y}px`;
                });
                
                // Place antagonists at top
                antagonists.forEach((node, i) => {
                    const angle = (Math.PI / 2) + ((i / antagonists.length) - 0.5) * Math.PI;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    node.style.left = `${x}px`;
                    node.style.top = `${y}px`;
                });
                
                // Place supporting characters at bottom right
                supporting.forEach((node, i) => {
                    const angle = (Math.PI * 7 / 4) + ((i / supporting.length) * Math.PI / 2);
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    node.style.left = `${x}px`;
                    node.style.top = `${y}px`;
                });
                    
                // Place others at bottom left
                others.forEach((node, i) => {
                    const angle = (Math.PI) + ((i / others.length) * Math.PI / 2);
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    node.style.left = `${x}px`;
                    node.style.top = `${y}px`;
                });
            }

            // Make these functions globally available
            window.characterRelationships = characterRelationships;
            window.updateCharacterNodePositions = updateCharacterNodePositions;
        });
    </script>
</body>
</html> 