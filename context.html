<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Context Manager - AIStoryCraft</title>
    <!-- Supabase Configuration -->
    <meta name="supabase-url" content="<%= process.env.SUPABASE_URL %>">
    <meta name="supabase-anon-key" content="<%= process.env.SUPABASE_ANON_KEY %>">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Merriweather:wght@400;700&display=swap" rel="stylesheet">
    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Frappe Gantt -->
    <script src="https://cdn.jsdelivr.net/npm/frappe-gantt@0.6.1/dist/frappe-gantt.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/frappe-gantt@0.6.1/dist/frappe-gantt.min.css">
    <!-- Supabase Module Import -->
    <script type="module">
        import { supabase, projects, locations, characters, timelineEvents } from './lib/supabase.js';
        
        window.supabaseModule = {
            supabase, projects, locations, characters, timelineEvents
        };
    </script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4B5EAA',
                        primaryLight: '#E6E9F0',
                        secondary: '#6B7280',
                        accent: '#F472B6',
                        background: '#F9FAFB',
                        textPrimary: '#1F2937',
                        textSecondary: '#9CA3AF',
                        success: '#34D399',
                        error: '#EF4444',
                        warning: '#FBBF24',
                        location: '#4CAF50',
                        event: '#EF4444',
                        character: '#4B5EAA'
                    }
                }
            }
        }
    </script>
    <style>
        :root {
            --primary: #4B5EAA;
            --primary-light: #E6E9F0;
            --secondary: #6B7280;
            --accent: #F472B6;
            --background: #F9FAFB;
            --text-primary: #1F2937;
            --text-secondary: #9CA3AF;
            --success: #34D399;
            --error: #EF4444;
            --warning: #FBBF24;
            --location: #4CAF50;
            --event: #EF4444;
            --character: #4B5EAA;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background);
            color: var(--text-primary);
        }

        /* Gantt Chart Customization */
        .gantt .bar {
            fill: var(--primary);
        }

        .gantt .bar.location {
            fill: var(--location);
        }

        .gantt .bar.event {
            fill: var(--event);
        }

        .gantt .bar.character {
            fill: var(--character);
        }

        .gantt .bar-label {
            fill: white;
            font-size: 12px;
        }

        .gantt .grid-header {
            fill: var(--background);
            stroke: var(--primary-light);
        }

        .gantt .grid-row {
            fill: white;
        }

        .gantt .row-line {
            stroke: var(--primary-light);
        }

        .gantt .lower-text, .gantt .upper-text {
            fill: var(--text-primary);
            font-size: 12px;
        }

        /* Character Tree Customization */
        .character-tree {
            position: relative;
            min-height: 300px;
            padding: 1rem;
            overflow: visible;
            z-index: 1;
        }

        .character-node {
            position: absolute;
            width: 100px;
            height: 40px;
            border-radius: 20px;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 2;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .character-node.protagonist {
            border: 2px solid var(--primary);
            color: var(--primary);
        }

        .character-node.antagonist {
            border: 2px solid var(--error);
            color: var(--error);
        }

        .character-node.supporting {
            border: 2px solid var(--accent);
            color: var(--accent);
        }

        .character-link {
            position: absolute;
            height: 1px;
            background-color: #ccc;
            transform-origin: 0 0;
            z-index: 1;
            pointer-events: none;
        }

        .character-node:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .role-badge.protagonist {
            background-color: rgba(75, 94, 170, 0.15);
            color: var(--primary);
        }

        .role-badge.antagonist {
            background-color: rgba(239, 68, 68, 0.15);
            color: var(--error);
        }

        .role-badge.supporting {
            background-color: rgba(244, 114, 182, 0.15);
            color: var(--accent);
        }

        /* Timeline Controls */
        .timeline-controls {
            position: sticky;
            top: 0;
            z-index: 30;
            background-color: white;
            border-bottom: 1px solid var(--primary-light);
            padding: 1rem;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: var(--primary-light);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background-color: var(--primary);
            color: white;
            box-shadow: 0 2px 4px rgba(75, 94, 170, 0.2);
        }

        .btn-primary:hover {
            background-color: #3F50A0;
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(75, 94, 170, 0.25);
        }

        /* Role badge styles */
        .role-badge {
            display: inline-flex;
            align-items: center;
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            font-weight: 500;
        }

        /* Modal overlay and container styles */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-container {
            background-color: white;
            border-radius: 0.5rem;
            padding: 1.5rem;
            width: 100%;
            max-width: 32rem;
            z-index: 51;
            position: relative;
        }

        /* Add styles for timeline */
        .timeline-cell {
            min-height: 70px;
            padding: 0;
            vertical-align: top;
            transition: background-color 0.2s;
            position: relative;
        }
        
        .timeline-cell:hover {
            background-color: rgba(75, 94, 170, 0.05);
        }
        
        .timeline-cell.drag-over {
            background-color: rgba(75, 94, 170, 0.1);
            border: 2px dashed var(--primary);
        }
        
        .character-tag {
            position: absolute;
            display: inline-block;
            min-width: 60px;
            margin: 0;
            cursor: move;
            transition: transform 0.1s;
            z-index: 10;
        }
        
        .character-tag:hover {
            transform: translateY(-2px);
            z-index: 20;
        }
        
        .character-item {
            transition: transform 0.1s, opacity 0.2s;
            cursor: move;
        }
        
        .character-item:hover {
            transform: translateY(-2px);
        }
        
        .character-item.dragging {
            opacity: 0.5;
        }
        
        /* Primary color based roles */
        .bg-primary { background-color: var(--primary); }
        .bg-error { background-color: var(--error); }
        .bg-accent { background-color: var(--accent); }
        
        /* Tab styling */
        .tab-btn {
            transition: all 0.2s ease;
        }
        
        .tab-btn.active {
            border-color: var(--primary);
            color: var(--primary);
        }
        
        .tab-content {
            display: block;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        .tab-content.hidden {
            display: none;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
</head>
<body class="h-screen flex flex-col">
    <!-- Header with tabs -->
    <header class="bg-white border-b border-gray-100">
        <div class="container mx-auto px-4 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-4">
                    <a href="index.html" class="text-gray-500 hover:text-primary">
                        <i class="fas fa-arrow-left"></i>
                        <span class="ml-2">Back to Editor</span>
                    </a>
                    <h1 class="text-xl font-semibold text-primary">Context Manager</h1>
                </div>
            </div>
            <!-- Tabs -->
            <div class="flex mt-6 border-b border-gray-200">
                <button class="tab-btn px-4 py-2 border-b-2 border-primary text-primary font-medium" data-tab="timeline">
                    <i class="fas fa-clock mr-2"></i>Story Timeline
                </button>
                <button class="tab-btn px-4 py-2 border-b-2 border-transparent hover:text-primary" data-tab="characters">
                    <i class="fas fa-users mr-2"></i>Characters
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto px-4 py-6">
        <!-- Timeline Tab View -->
        <div class="tab-content" id="timelineTab">
            <div class="flex h-[calc(100vh-170px)]">
                <!-- Characters Sidebar (Left) -->
                <div class="w-64 bg-white shadow-md border border-gray-100 rounded-l-lg overflow-y-auto">
                    <div class="p-4 border-b border-gray-100">
                        <h2 class="text-lg font-semibold text-primary">Characters</h2>
                        <p class="text-sm text-gray-500 mt-1">Drag characters to the timeline</p>
                    </div>
                    <div id="charactersList" class="p-4 space-y-2">
                        <!-- Character items for dragging -->
                        <div class="character-item bg-white border-2 border-primary text-primary p-2 rounded-lg cursor-move shadow-sm" 
                             draggable="true" data-name="Elizabeth" data-color="blue" data-role="Protagonist">
                            <div class="text-sm font-medium">Elizabeth</div>
                        </div>
                        <div class="character-item bg-white border-2 border-error text-error p-2 rounded-lg cursor-move shadow-sm" 
                             draggable="true" data-name="James" data-color="red" data-role="Antagonist">
                            <div class="text-sm font-medium">James</div>
                        </div>
                        <div class="character-item bg-white border-2 border-accent text-accent p-2 rounded-lg cursor-move shadow-sm" 
                             draggable="true" data-name="Sarah" data-color="green" data-role="Supporting">
                            <div class="text-sm font-medium">Sarah</div>
                        </div>
                    </div>
                </div>

                <!-- Timeline Gantt Chart (Right) -->
                <div class="flex-1 bg-white shadow-md border border-gray-100 rounded-r-lg overflow-auto">
                    <div class="p-4 border-b border-gray-100 flex justify-between items-center sticky top-0 bg-white z-10">
                        <h2 class="text-lg font-semibold text-primary">Story Timeline</h2>
                        <div class="flex items-center space-x-3">
                            <select id="daySelector" class="border border-gray-200 rounded-lg p-2 text-sm">
                                <option value="1">Day 1</option>
                                <option value="2">Day 2</option>
                                <option value="3">Day 3</option>
                                <option value="4">Day 4</option>
                                <option value="5">Day 5</option>
                            </select>
                            <button class="btn btn-primary text-xs py-1 px-2" id="addLocationBtn" title="Add Location">
                                <i class="fas fa-plus text-xs mr-1"></i>Add Location
                            </button>
                        </div>
                    </div>

                    <!-- Timeline Grid -->
                    <div class="p-4">
                        <div class="timeline-grid border border-gray-200 rounded-lg overflow-x-auto">
                            <table class="w-full min-w-max">
                                <thead>
                                    <tr>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-3 text-left"></th>
                                        <!-- Generate 24 columns for each hour -->
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">00:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">01:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">02:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">03:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">04:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">05:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">06:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">07:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">08:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">09:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">10:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">11:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">12:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">13:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">14:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">15:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">16:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">17:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">18:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">19:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">20:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">21:00</th>
                                        <th class="w-20 border-r border-b border-gray-200 bg-gray-50 p-2 text-center">22:00</th>
                                        <th class="w-20 border-b border-gray-200 bg-gray-50 p-2 text-center">23:00</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td class="border-r border-b border-gray-200 p-3 font-medium">Castle</td>
                                        <!-- Generate 24 cells for each hour -->
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="0" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="1" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="2" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="3" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="4" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="5" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="6" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="7" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="8" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="9" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="10" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="11" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="12" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="13" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="14" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="15" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="16" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="17" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="18" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="19" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="20" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="21" data-location="Castle"></td>
                                        <td class="border-r border-b border-gray-200 timeline-cell relative" data-time="22" data-location="Castle"></td>
                                        <td class="border-b border-gray-200 timeline-cell relative" data-time="23" data-location="Castle"></td>
                                    </tr>
                                    <!-- Repeat similar structure for other locations -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Characters Tab View -->
        <div class="tab-content hidden" id="charactersTab">
            <!-- Character Tree View -->
            <div class="bg-white shadow-md border border-gray-100 rounded-lg p-6">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-semibold text-primary">Characters Network</h2>
                    <button class="btn btn-primary text-sm" onclick="openModal('character')">
                        <i class="fas fa-plus text-sm mr-1"></i>
                        New Character
                    </button>
                </div>
                
                <div class="character-tree relative p-8 min-h-[400px] border border-gray-100 rounded-lg mb-6" id="characterTreeContainer">
                    <!-- Character nodes positioned to match reference image -->
                    <div class="character-node protagonist" style="top: 120px; left: 50%; transform: translateX(-50%);" data-name="John Doe" data-role="Protagonist" data-traits="Brave, curious explorer" data-backstory="Survived an accident in New York">
                        <div class="font-medium text-center">John</div>
                    </div>
                    <div class="character-node antagonist" style="top: 220px; left: 30%;" data-name="Mystery Figure" data-role="Antagonist" data-traits="Enigmatic, threatening" data-backstory="Unknown entity connected to the accident">
                        <div class="font-medium text-center">Mystery</div>
                    </div>
                    <div class="character-node supporting" style="top: 220px; left: 70%;" data-name="Sarah" data-role="Supporting" data-traits="Supportive, knowledgeable" data-backstory="John's friend who helps him navigate his return">
                        <div class="font-medium text-center">Sarah</div>
                    </div>
                    
                    <!-- Predefined connection lines like in the reference image -->
                    <div class="character-link" style="width: 225px; top: 140px; left: 50%; transform: rotate(45deg) translateX(-50%);"></div>
                    <div class="character-link" style="width: 225px; top: 140px; left: 50%; transform: rotate(-45deg) translateX(-50%);"></div>
                </div>
                
                <div class="flex justify-center space-x-6 text-sm">
                    <div class="flex items-center">
                        <div class="w-3 h-3 rounded-full bg-primary mr-2"></div>
                        <span>Protagonist</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-3 h-3 rounded-full bg-error mr-2"></div>
                        <span>Antagonist</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-3 h-3 rounded-full bg-accent mr-2"></div>
                        <span>Supporting</span>
                    </div>
                </div>
            </div>
            
            <!-- Character Details Panel -->
            <div id="characterDetailsPanel" class="fixed inset-y-0 right-0 w-96 bg-white shadow-lg transform translate-x-full transition-transform duration-300 z-50">
                <div class="h-full flex flex-col">
                    <div class="p-6 border-b border-gray-100">
                        <div class="flex items-center justify-between mb-4">
                            <h2 class="text-xl font-bold text-primary" id="characterDetailName">Character Name</h2>
                            <button class="text-gray-400 hover:text-gray-600" onclick="closeCharacterDetails()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="inline-flex items-center px-3 py-1 rounded-full text-sm" id="characterDetailRole">
                            Role
                        </div>
                    </div>
                    
                    <div class="flex-1 overflow-y-auto p-6">
                        <div class="space-y-6">
                            <div>
                                <h3 class="text-sm font-semibold text-gray-500 uppercase tracking-wider mb-2">Traits</h3>
                                <p class="text-gray-700" id="characterDetailTraits">Character traits will appear here</p>
                            </div>
                            
                            <div>
                                <h3 class="text-sm font-semibold text-gray-500 uppercase tracking-wider mb-2">Backstory</h3>
                                <p class="text-gray-700" id="characterDetailBackstory">Character backstory will appear here</p>
                            </div>
                            
                            <div>
                                <h3 class="text-sm font-semibold text-gray-500 uppercase tracking-wider mb-2">Relationships</h3>
                                <div class="space-y-2" id="characterDetailRelationships">
                                    <!-- Relationships will be added here -->
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="p-6 border-t border-gray-100">
                        <button class="btn btn-primary w-full" id="editCharacterBtn">
                            <i class="fas fa-edit mr-2"></i>
                            Edit Character
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Add Item Modal -->
    <div id="addItemModal" class="modal-overlay hidden">
        <div class="modal-container">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-xl font-bold text-primary">Edit Character</h2>
                <button onclick="closeModal()" class="text-gray-400 hover:text-gray-600">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Type</label>
                    <select class="w-full border border-gray-200 rounded-lg p-2">
                        <option value="character">Character</option>
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Name</label>
                    <input type="text" class="w-full border border-gray-200 rounded-lg p-2">
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Description</label>
                    <textarea class="w-full border border-gray-200 rounded-lg p-2 h-32"></textarea>
                </div>
                
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Start Date</label>
                        <input type="date" class="w-full border border-gray-200 rounded-lg p-2">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">End Date</label>
                        <input type="date" class="w-full border border-gray-200 rounded-lg p-2">
                    </div>
                </div>
                
                <div class="flex justify-end space-x-3 pt-4">
                    <button onclick="closeModal()" class="btn btn-secondary">Cancel</button>
                    <button class="btn btn-primary">Add Item</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Event Creation Modal -->
    <div id="eventCreationModal" class="fixed inset-0 bg-black bg-opacity-60 hidden items-center justify-center z-50">
        <div class="bg-white rounded-xl p-6 max-w-md w-full mx-4 shadow-md-custom">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-xl font-bold text-primary">Create Timeline Event</h2>
                <button class="text-gray-400 hover:text-gray-600" id="closeEventModal">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Event Name <span class="text-error">*</span></label>
                    <input type="text" id="eventName" class="w-full px-4 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent" placeholder="Enter event name">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Time</label>
                    <input type="time" id="eventTime" class="w-full px-4 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Description</label>
                    <textarea id="eventDescription" class="w-full px-4 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent h-24" placeholder="Describe what happens in this event"></textarea>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Characters Involved</label>
                    <div id="eventCharacters" class="space-y-2 bg-gray-50 p-2 rounded-lg min-h-[50px]">
                        <!-- Characters will be listed here -->
                    </div>
                </div>
                <div class="flex justify-end space-x-3 pt-4">
                    <button id="cancelEvent" class="btn btn-secondary">Cancel</button>
                    <button id="createEvent" class="btn btn-primary">Create Event</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Event Details Panel -->
    <div id="eventDetailsPanel" class="fixed right-0 top-0 h-screen w-96 bg-white shadow-lg transform translate-x-full transition-transform duration-300 z-40">
        <div class="h-full flex flex-col">
            <div class="p-6 border-b border-gray-100">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-xl font-bold text-primary" id="eventDetailName">Event Name</h2>
                    <button class="text-gray-400 hover:text-gray-600" onclick="closeEventDetails()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="text-sm text-gray-500" id="eventDetailTime">Time: --:--</div>
            </div>
            
            <div class="flex-1 overflow-y-auto p-6">
                <div class="space-y-6">
                    <div>
                        <h3 class="text-sm font-semibold text-gray-500 uppercase tracking-wider mb-2">Description</h3>
                        <p class="text-gray-700" id="eventDetailDescription">Event description will appear here</p>
                    </div>
                    
                    <div>
                        <h3 class="text-sm font-semibold text-gray-500 uppercase tracking-wider mb-2">Characters Involved</h3>
                        <div class="space-y-2" id="eventDetailCharacters">
                            <!-- Characters will be listed here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="p-6 border-t border-gray-100">
                <button class="btn btn-primary w-full" id="editEventBtn">
                    <i class="fas fa-edit mr-2"></i>
                    Edit Event
                </button>
            </div>
        </div>
    </div>

    <!-- Location Modal -->
    <div id="locationModal" class="fixed inset-0 bg-black bg-opacity-60 hidden items-center justify-center z-50">
        <div class="bg-white rounded-xl p-6 max-w-md w-full mx-4 shadow-md-custom">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-xl font-bold text-primary">Add Location</h2>
                <button class="text-gray-400 hover:text-gray-600" id="closeLocationModal">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Location Name <span class="text-error">*</span></label>
                    <input type="text" id="locationName" class="w-full px-4 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent" placeholder="Enter location name">
                </div>
                <div class="flex justify-end space-x-3 pt-4">
                    <button id="cancelLocation" class="btn btn-secondary">Cancel</button>
                    <button id="createLocation" class="btn btn-primary">Add Location</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Application state
            let currentProjectId = null;
            let pendingEventCell = null;
            let pendingEventCharacters = [];
            let currentEventData = null;
            let currentCharacterData = null;
            let networkClickPosition = { x: 0, y: 0 };
            
            // Supabase helpers
            const { supabase, projects, locations, characters, timelineEvents } = window.supabaseModule;
            
            // Initialize application with Supabase data
            async function initializeApp() {
                try {
                    // Show loading indicator
                    showLoadingOverlay("Loading project data...");
                    
                    // 1. Get project ID from URL or local storage
                    const urlParams = new URLSearchParams(window.location.search);
                    currentProjectId = urlParams.get('project') || localStorage.getItem('currentProjectId');
                    
                    if (!currentProjectId) {
                        // Redirect back to the main page if no project ID
                        window.location.href = 'index.html';
                        return;
                    }
                    
                    // Save project ID to localStorage for persistence
                    localStorage.setItem('currentProjectId', currentProjectId);
                    
                    // 2. Load project data
                    const { data: project, error: projectError } = await projects.getById(currentProjectId);
                    
                    if (projectError || !project) {
                        console.error("Error loading project:", projectError);
                        hideLoadingOverlay();
                        showError("Failed to load project data. Please try again.");
                        return;
                    }
                    
                    // 3. Set project title
                    document.querySelector('#projectTitle').textContent = project.title || 'Story Context';
                    
                    // 4. Load data in parallel
                    await Promise.all([
                        loadLocations(),
                        loadCharacters(),
                        loadTimelineEvents()
                    ]);
                    
                    // 5. Initialize UI components
                    initTabs();
                    initializeCharacterDragEvents();
                    
                    // Hide loading overlay
                    hideLoadingOverlay();
                } catch (error) {
                    console.error("Initialization error:", error);
                    hideLoadingOverlay();
                    showError("An error occurred during initialization. Please try again.");
                }
            }
            
            // Data loading functions
            async function loadLocations() {
                try {
                    // Show loading section indicator
                    updateSectionLoadingState("locations", true, "Loading locations...");
                    
                    // Fetch locations for current project from Supabase
                    const { data: locationData, error } = await window.supabaseModule.locations.getByProject(currentProjectId);
                    
                    if (error) {
                        console.error("Error loading locations:", error);
                        showError("Failed to load locations data.");
                        return;
                    }
                    
                    // Clear existing locations from the timeline
                    const timelineBody = document.querySelector('.timeline-grid table tbody');
                    timelineBody.innerHTML = '';
                    
                    // If no locations, add a default message
                    if (!locationData || locationData.length === 0) {
                        const emptyRow = document.createElement('tr');
                        emptyRow.innerHTML = `
                            <td colspan="25" class="text-center py-8 text-gray-500">
                                <i class="fas fa-map-marker-alt mb-2 text-2xl"></i>
                                <p>No locations added yet.</p>
                                <button id="addFirstLocationBtn" class="btn btn-primary text-xs mt-2">
                                    <i class="fas fa-plus text-xs mr-1"></i>Add Your First Location
                                </button>
                            </td>
                        `;
                        timelineBody.appendChild(emptyRow);
                        
                        // Add click handler for the empty state button
                        document.getElementById('addFirstLocationBtn')?.addEventListener('click', showLocationModal);
                        
                        // Hide loading indicator
                        updateSectionLoadingState("locations", false);
                        return;
                    }
                    
                    // Add locations to the timeline
                    locationData.forEach(location => {
                        const newRow = document.createElement('tr');
                        newRow.innerHTML = `
                            <td class="border-r border-b border-gray-200 p-3 font-medium" data-location-id="${location.id}">${location.name}</td>
                            ${Array(24).fill(0).map((_, i) => `
                                <td class="border-r border-b border-gray-200 timeline-cell relative" 
                                    data-time="${i}" 
                                    data-location="${location.name}" 
                                    data-location-id="${location.id}"></td>
                            `).join('')}
                        `;
                        timelineBody.appendChild(newRow);
                        
                        // Add event handlers for the cells
                        newRow.querySelectorAll('.timeline-cell').forEach(cell => {
                            cell.addEventListener('dragover', e => e.preventDefault());
                            cell.addEventListener('drop', handleTimelineCellDrop);
                        });
                    });
                    
                    // Hide loading indicator
                    updateSectionLoadingState("locations", false);
                } catch (error) {
                    console.error("Error in loadLocations:", error);
                    updateSectionLoadingState("locations", false);
                    showError("Failed to load locations data.");
                }
            }
            
            async function loadCharacters() {
                try {
                    // Show loading indicator
                    updateSectionLoadingState("characters", true, "Loading characters...");
                    
                    // Fetch characters for current project from Supabase
                    const { data: characterData, error } = await window.supabaseModule.characters.getByProject(currentProjectId);
                    
                    if (error) {
                        console.error("Error loading characters:", error);
                        showError("Failed to load character data.");
                        return;
                    }
                    
                    // Clear existing characters from both places
                    const characterList = document.getElementById('charactersList');
                    const characterTreeContainer = document.getElementById('characterTreeContainer');
                    
                    characterList.innerHTML = '';
                    
                    // Clear character tree but keep any helper elements
                    const helperElements = Array.from(characterTreeContainer.querySelectorAll(':not(.character-node):not(.character-link)'));
                    characterTreeContainer.innerHTML = '';
                    helperElements.forEach(element => characterTreeContainer.appendChild(element));
                    
                    // If no characters, add a default message to the sidebar
                    if (!characterData || characterData.length === 0) {
                        characterList.innerHTML = `
                            <div class="text-center py-6 text-gray-500">
                                <i class="fas fa-users mb-2 text-xl"></i>
                                <p class="text-sm mb-2">No characters added yet.</p>
                            </div>
                        `;
                        
                        // Update character count
                        const characterCountElement = document.querySelector('#characterTreeView span.text-xs');
                        if (characterCountElement) {
                            characterCountElement.textContent = '0 characters';
                        }
                        
                        // Hide loading indicator
                        updateSectionLoadingState("characters", false);
                        return;
                    }
                    
                    // Add characters to the character list sidebar for dragging
                    characterData.forEach(character => {
                        // Determine color class based on role
                        let borderColorClass = 'border-primary';
                        let textColorClass = 'text-primary';
                        
                        if (character.role === 'Antagonist') {
                            borderColorClass = 'border-error';
                            textColorClass = 'text-error';
                        } else if (character.role === 'Supporting') {
                            borderColorClass = 'border-accent';
                            textColorClass = 'text-accent';
                        }
                        
                        // Create draggable character item for the sidebar
                        const characterItem = document.createElement('div');
                        characterItem.className = `character-item bg-white border-2 ${borderColorClass} ${textColorClass} p-2 rounded-lg cursor-move shadow-sm`;
                        characterItem.setAttribute('draggable', 'true');
                        characterItem.setAttribute('data-character-id', character.id);
                        characterItem.setAttribute('data-name', character.name);
                        characterItem.setAttribute('data-role', character.role);
                        
                        characterItem.innerHTML = `
                            <div class="text-sm font-medium">${character.name}</div>
                        `;
                        
                        // Add to character list
                        characterList.appendChild(characterItem);
                        
                        // Add drag event listener
                        characterItem.addEventListener('dragstart', handleCharacterDragStart);
                        
                        // Also add to character network visualization
                        // Calculate position - for now we'll place them in a radial pattern
                        const characterCount = characterTreeContainer.querySelectorAll('.character-node').length;
                        const angle = characterCount * (Math.PI / 4);
                        const centerX = characterTreeContainer.offsetWidth / 2;
                        const centerY = 120;
                        const radius = 100;
                        
                        const posX = centerX + radius * Math.cos(angle);
                        const posY = centerY + radius * Math.sin(angle);
                        
                        // Create node in character tree
                        addCharacterToTree({
                            id: character.id,
                            name: character.name,
                            role: character.role,
                            traits: character.traits || '',
                            backstory: character.backstory || ''
                        }, posX, posY);
                    });
                    
                    // Update character relationships
                    updateCharacterRelationships(characterData);
                    
                    // Update character count
                    const characterCountElement = document.querySelector('#characterTreeView span.text-xs');
                    if (characterCountElement) {
                        characterCountElement.textContent = `${characterData.length} character${characterData.length !== 1 ? 's' : ''}`;
                    }
                    
                    // Hide loading indicator
                    updateSectionLoadingState("characters", false);
                } catch (error) {
                    console.error("Error in loadCharacters:", error);
                    updateSectionLoadingState("characters", false);
                    showError("Failed to load character data.");
                }
            }
            
            async function loadTimelineEvents() {
                try {
                    // Show loading indicator
                    updateSectionLoadingState("timeline", true, "Loading timeline events...");
                    
                    // Fetch timeline events for current project from Supabase
                    const { data: eventData, error } = await window.supabaseModule.timelineEvents.getByProject(currentProjectId);
                    
                    if (error) {
                        console.error("Error loading timeline events:", error);
                        showError("Failed to load timeline events.");
                        return;
                    }
                    
                    // Clear existing events from timeline
                    document.querySelectorAll('.timeline-event').forEach(el => el.remove());
                    
                    // If no events, we don't need to display anything special
                    if (!eventData || eventData.length === 0) {
                        // Hide loading indicator
                        updateSectionLoadingState("timeline", false);
                        return;
                    }
                    
                    // Add events to timeline
                    eventData.forEach(event => {
                        try {
                            // Extract time info from date_time field (format could be "12:00" or ISO date)
                            let hour = 0;
                            if (event.date_time) {
                                // Check if it's just a time string like "12:00"
                                const timeMatch = event.date_time.match(/^(\d{1,2}):/);
                                if (timeMatch) {
                                    hour = parseInt(timeMatch[1]);
                                } else {
                                    // Try to parse as ISO date
                                    const date = new Date(event.date_time);
                                    if (!isNaN(date.getTime())) {
                                        hour = date.getHours();
                                    }
                                }
                            }
                            
                            // Find the right cell based on location_id and time
                            const cell = document.querySelector(`.timeline-cell[data-location-id="${event.location_id}"][data-time="${hour}"]`);
                            
                            if (cell) {
                                // Create event element
                                const eventElement = document.createElement('div');
                                eventElement.className = 'timeline-event bg-primary text-white p-1 text-xs rounded text-center cursor-pointer';
                                eventElement.textContent = event.name;
                                eventElement.setAttribute('data-event-id', event.id);
                                eventElement.setAttribute('data-time', event.date_time);
                                eventElement.setAttribute('data-description', event.description || '');
                                
                                // Character data (if stored as JSON string, parse it)
                                let charactersData = [];
                                if (event.characters) {
                                    try {
                                        if (typeof event.characters === 'string') {
                                            charactersData = JSON.parse(event.characters);
                                        } else if (Array.isArray(event.characters)) {
                                            charactersData = event.characters;
                                        }
                                    } catch (e) {
                                        console.error("Error parsing characters data:", e);
                                    }
                                }
                                eventElement.setAttribute('data-characters', JSON.stringify(charactersData));
                                
                                // Add to cell
                                cell.appendChild(eventElement);
                                
                                // Add event handlers
                                eventElement.addEventListener('dragover', e => e.preventDefault());
                                eventElement.addEventListener('drop', handleEventDrop);
                                eventElement.addEventListener('click', showEventDetails);
                            }
                        } catch (err) {
                            console.error("Error displaying event:", err, event);
                        }
                    });
                    
                    // Hide loading indicator
                    updateSectionLoadingState("timeline", false);
                } catch (error) {
                    console.error("Error in loadTimelineEvents:", error);
                    updateSectionLoadingState("timeline", false);
                    showError("Failed to load timeline events.");
                }
            }
            
            // Helper function for section loading states
            function updateSectionLoadingState(section, isLoading, message = "Loading...") {
                const sectionLoadingId = `${section}LoadingIndicator`;
                let loadingEl = document.getElementById(sectionLoadingId);
                
                if (isLoading) {
                    // Create loading indicator if it doesn't exist
                    if (!loadingEl) {
                        loadingEl = document.createElement('div');
                        loadingEl.id = sectionLoadingId;
                        loadingEl.className = "absolute inset-0 bg-white bg-opacity-80 flex items-center justify-center z-10";
                        loadingEl.innerHTML = `
                            <div class="text-center">
                                <i class="fas fa-circle-notch fa-spin text-primary text-xl mb-2"></i>
                                <p class="text-sm text-gray-600">${message}</p>
                            </div>
                        `;
                        
                        // Add to appropriate container
                        let container;
                        if (section === "locations" || section === "timeline") {
                            container = document.querySelector('.timeline-grid');
                        } else if (section === "characters") {
                            container = document.getElementById('characterTreeContainer');
                        }
                        
                        if (container) {
                            // Make container relative if it's not already
                            if (getComputedStyle(container).position === 'static') {
                                container.style.position = 'relative';
                            }
                            container.appendChild(loadingEl);
                        }
                    }
                } else {
                    // Remove loading indicator if it exists
                    if (loadingEl) {
                        loadingEl.remove();
                    }
                }
            }
            
            // UI helper functions
            function showLoadingOverlay(message = "Loading...") {
                const overlay = document.createElement('div');
                overlay.id = "loadingOverlay";
                overlay.className = "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50";
                overlay.innerHTML = `
                    <div class="bg-white p-4 rounded-lg shadow-lg text-center">
                        <div class="mb-2">
                            <i class="fas fa-circle-notch fa-spin text-primary text-2xl"></i>
                        </div>
                        <p id="loadingMessage">${message}</p>
                    </div>
                `;
                document.body.appendChild(overlay);
            }
            
            function hideLoadingOverlay() {
                const overlay = document.getElementById('loadingOverlay');
                if (overlay) {
                    overlay.remove();
                }
            }
            
            function showError(message) {
                const errorToast = document.createElement('div');
                errorToast.className = "fixed top-4 right-4 bg-error text-white p-3 rounded-lg shadow-md";
                errorToast.innerHTML = `<p>${message}</p>`;
                document.body.appendChild(errorToast);
                
                setTimeout(() => {
                    errorToast.remove();
                }, 5000);
            }
            
            // UI Helper functions
            function initTabs() {
                const tabButtons = document.querySelectorAll('.tab-btn');
                const tabContents = document.querySelectorAll('.tab-content');
                
                tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        // Remove active class from all buttons
                        tabButtons.forEach(btn => {
                            btn.classList.remove('active', 'border-primary', 'text-primary');
                            btn.classList.add('border-transparent');
                        });
                        
                        // Add active class to clicked button
                        button.classList.add('active', 'border-primary', 'text-primary');
                        button.classList.remove('border-transparent');
                        
                        // Hide all tab contents
                        tabContents.forEach(content => {
                            content.classList.add('hidden');
                        });
                        
                        // Show the selected tab content
                        const tabName = button.getAttribute('data-tab');
                        document.getElementById(tabName + 'Tab').classList.remove('hidden');
                    });
                });
                
                // Select the first tab by default if none are active
                if (!document.querySelector('.tab-btn.active')) {
                    const firstTab = document.querySelector('.tab-btn');
                    if (firstTab) {
                        firstTab.click();
                    }
                }
            }
            
            // Add these styles needed for drag and drop
            function addDragDropStyles() {
                const style = document.createElement('style');
                style.textContent = `
                    .timeline-cell {
                        position: relative;
                        min-height: 70px;
                        transition: background-color 0.2s;
                    }
                    
                    .timeline-cell.drag-over {
                        background-color: rgba(75, 94, 170, 0.1);
                    }
                    
                    .character-tag {
                        position: absolute;
                        min-width: 60px;
                        z-index: 10;
                        cursor: move;
                        transition: transform 0.2s;
                    }
                    
                    .character-tag:hover {
                        transform: translateY(-2px);
                        z-index: 20;
                    }
                    
                    .timeline-event {
                        position: absolute;
                        min-width: 60px;
                        z-index: 10;
                        left: 50%;
                        top: 50%;
                        transform: translate(-50%, -50%);
                        transition: all 0.2s ease;
                    }
                    
                    .timeline-event:hover {
                        transform: translate(-50%, -50%) translateY(-2px);
                        z-index: 20;
                        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Helper to find the closest timeline cell
            function findClosestTimelineCell(x, y) {
                const cells = document.querySelectorAll('.timeline-cell');
                let closestCell = null;
                let closestDistance = Infinity;

                cells.forEach(cell => {
                    const rect = cell.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const distance = Math.sqrt(
                        Math.pow(x - centerX, 2) + 
                        Math.pow(y - centerY, 2)
                    );

                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestCell = cell;
                    }
                });

                return closestCell;
            }
            
            // Get character color class based on role
            function getCharacterColorClass(role) {
                switch (role) {
                    case 'Antagonist': return 'bg-error';
                    case 'Supporting': return 'bg-accent';
                    default: return 'bg-primary';
                }
            }
            
            // Location functionality with Supabase integration
            function showLocationModal() {
                const modal = document.getElementById('locationModal');
                modal.classList.remove('hidden');
                modal.classList.add('flex');
                document.getElementById('locationName').focus();
            }

            function closeLocationModal() {
                const modal = document.getElementById('locationModal');
                modal.classList.add('hidden');
                document.getElementById('locationName').value = '';
            }

            async function addLocation(locationName) {
                if (!locationName.trim()) return;
                
                try {
                    // Show loading indicator
                    const createButton = document.getElementById('createLocation');
                    createButton.disabled = true;
                    createButton.innerHTML = '<i class="fas fa-circle-notch fa-spin text-xs mr-1"></i>Creating...';
                    
                    // Create location in Supabase
                    const { data: location, error } = await window.supabaseModule.locations.create({
                        name: locationName,
                        project_id: currentProjectId
                    });
                    
                    if (error) {
                        console.error('Error creating location:', error);
                        showError('Failed to create location. Please try again.');
                        
                        // Reset button
                        createButton.disabled = false;
                        createButton.innerHTML = 'Create Location';
                        return;
                    }
                    
                    // Add to UI
                    const tbody = document.querySelector('.timeline-grid table tbody');
                    
                    // If there's an empty state message, remove it
                    const emptyMessage = tbody.querySelector('tr td[colspan="25"]');
                    if (emptyMessage) {
                        tbody.innerHTML = '';
                    }
                    
                    const newRow = document.createElement('tr');
                    newRow.innerHTML = `
                        <td class="border-r border-b border-gray-200 p-3 font-medium" data-location-id="${location.id}">${location.name}</td>
                        ${Array(24).fill(0).map((_, i) => `
                            <td class="border-r border-b border-gray-200 timeline-cell relative" 
                                data-time="${i}" 
                                data-location="${location.name}" 
                                data-location-id="${location.id}"></td>
                        `).join('')}
                    `;
                    tbody.appendChild(newRow);
                    
                    // Add event handlers for timeline cells
                    newRow.querySelectorAll('.timeline-cell').forEach(cell => {
                        cell.addEventListener('dragover', e => e.preventDefault());
                        cell.addEventListener('drop', handleTimelineCellDrop);
                    });
                    
                    // Close the modal
                    closeLocationModal();
                } catch (error) {
                    console.error('Error in addLocation:', error);
                    showError('An error occurred while creating the location.');
                    
                    // Reset button
                    const createButton = document.getElementById('createLocation');
                    createButton.disabled = false;
                    createButton.innerHTML = 'Create Location';
                }
            }
            
            // Add event listeners for location buttons
            document.addEventListener('DOMContentLoaded', function() {
                // Add Location button
                document.getElementById('addLocationBtn')?.addEventListener('click', showLocationModal);
                
                // Location Modal handlers
                document.getElementById('closeLocationModal')?.addEventListener('click', closeLocationModal);
                document.getElementById('cancelLocation')?.addEventListener('click', closeLocationModal);
                document.getElementById('createLocation')?.addEventListener('click', () => {
                    const locationName = document.getElementById('locationName').value.trim();
                    if (locationName) {
                        addLocation(locationName);
                    } else {
                        alert('Please enter a location name');
                    }
                });
            });
            
            // Timeline drag-and-drop functionality
            let draggedItem = null;
            
            function handleCharacterDragStart(e) {
                draggedItem = this;
                this.classList.add('dragging');
                
                // Store character data
                const charData = {
                    id: this.getAttribute('data-character-id'),
                    name: this.getAttribute('data-name'),
                    role: this.getAttribute('data-role')
                };
                e.dataTransfer.setData('text/plain', JSON.stringify(charData));
            }
            
            function handleTimelineCellDrop(e) {
                e.preventDefault();
                document.querySelectorAll('.timeline-cell').forEach(c => c.classList.remove('drag-over'));
                
                try {
                    const charData = JSON.parse(e.dataTransfer.getData('text/plain'));
                    
                    // Create new event
                    pendingEventCell = this;
                    pendingEventCharacters = [charData];
                    
                    // Get time value from the cell
                    const timeValue = this.getAttribute('data-time') || "0";
                    console.log("Time value passed to modal:", timeValue);
                    showEventCreationModal(timeValue);
                } catch (error) {
                    console.error('Error handling drop:', error);
                }
            }
            
            function handleEventDrop(e) {
                e.preventDefault();
                e.stopPropagation();
                
                try {
                    const charData = JSON.parse(e.dataTransfer.getData('text/plain'));
                    const eventId = this.getAttribute('data-event-id');
                    addCharacterToEvent(eventId, charData);
                } catch (error) {
                    console.error('Error adding character to event:', error);
                }
            }
            
            function initializeCharacterDragEvents() {
                const characterItems = document.querySelectorAll('.character-item');
                const timelineCells = document.querySelectorAll('.timeline-cell');
                
                // Setup drag events for character items
                characterItems.forEach(item => {
                    item.addEventListener('dragstart', handleCharacterDragStart);
                });
                
                // Setup drop zone for timeline cells
                timelineCells.forEach(cell => {
                    cell.addEventListener('dragover', e => {
                        e.preventDefault();
                        cell.classList.add('drag-over');
                    });
                    
                    cell.addEventListener('dragleave', () => {
                        cell.classList.remove('drag-over');
                    });
                    
                    cell.addEventListener('drop', handleTimelineCellDrop);
                });
                
                // Setup drop zone for timeline grid (needed for when cells are empty)
                document.querySelector('.timeline-grid')?.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    const cell = findClosestTimelineCell(e.clientX, e.clientY);
                    if (cell) {
                        document.querySelectorAll('.timeline-cell').forEach(c => c.classList.remove('drag-over'));
                        cell.classList.add('drag-over');
                    }
                });
                
                document.querySelector('.timeline-grid')?.addEventListener('dragleave', function() {
                    document.querySelectorAll('.timeline-cell').forEach(c => c.classList.remove('drag-over'));
                });
                
                document.querySelector('.timeline-grid')?.addEventListener('drop', function(e) {
                    e.preventDefault();
                    
                    const cell = findClosestTimelineCell(e.clientX, e.clientY);
                    if (!cell) return;
                    
                    document.querySelectorAll('.timeline-cell').forEach(c => c.classList.remove('drag-over'));
                    handleTimelineCellDrop.call(cell, e);
                });
            }
            
            // Timeline event functions with Supabase integration
            function showEventCreationModal(time) {
                const modal = document.getElementById('eventCreationModal');
                const timeInput = document.getElementById('eventTime');
                const charactersContainer = document.getElementById('eventCharacters');
                
                // Reset form state first
                document.getElementById('eventName').value = '';
                document.getElementById('eventDescription').value = '';
                document.querySelector('#eventCreationModal h2').textContent = 'Create Timeline Event';
                document.getElementById('createEvent').textContent = 'Create Event';
                
                // Set default time from cell - ensure we have a valid format
                const hourValue = parseInt(time) || 0;
                timeInput.value = hourValue.toString().padStart(2, '0') + ':00';
                
                // Display initial characters
                charactersContainer.innerHTML = pendingEventCharacters.map(char => `
                    <div class="flex items-center justify-between p-2 bg-white rounded">
                        <span class="flex items-center">
                            <div class="w-2 h-2 rounded-full ${getCharacterColorClass(char.role)} mr-2"></div>
                            ${char.name}
                        </span>
                        <button class="text-error hover:text-opacity-80" onclick="removeCharacterFromPending('${char.name}')">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `).join('');
                
                // Show the modal
                modal.classList.remove('hidden');
                modal.classList.add('flex');
                document.getElementById('eventName').focus();
            }
            
            async function createTimelineEvent(name, time, description, characters, isUpdate = false) {
                try {
                    // Determine location ID from the cell
                    const locationId = pendingEventCell ? pendingEventCell.getAttribute('data-location-id') : null;
                    
                    if (!locationId) {
                        console.error("Error: No location ID found for event");
                        showError("Could not determine location for event.");
                        return null;
                    }
                    
                    // Prepare event data
                    const eventData = {
                        name: name,
                        date_time: time,
                        description: description,
                        location_id: locationId,
                        project_id: currentProjectId,
                        characters: JSON.stringify(characters)
                    };
                    
                    // Submit to Supabase
                    let result;
                    
                    if (isUpdate && currentEventData && currentEventData.id) {
                        // Update existing event
                        result = await window.supabaseModule.timelineEvents.update(
                            currentEventData.id,
                            eventData
                        );
                    } else {
                        // Create new event
                        result = await window.supabaseModule.timelineEvents.create(eventData);
                    }
                    
                    const { data: event, error } = result;
                    
                    if (error) {
                        console.error("Error saving timeline event:", error);
                        showError("Failed to save event to database.");
                        return null;
                    }
                    
                    // Create UI element
                    const eventElement = document.createElement('div');
                    eventElement.className = 'timeline-event bg-primary text-white p-1 text-xs rounded text-center cursor-pointer';
                    eventElement.textContent = name;
                    eventElement.setAttribute('data-event-id', event.id);
                    eventElement.setAttribute('data-characters', JSON.stringify(characters));
                    eventElement.setAttribute('data-time', time);
                    eventElement.setAttribute('data-description', description);
                    
                    // Make the event droppable for additional characters
                    eventElement.addEventListener('dragover', e => e.preventDefault());
                    eventElement.addEventListener('drop', handleEventDrop);
                    eventElement.addEventListener('click', showEventDetails);
                    
                    return eventElement;
                } catch (error) {
                    console.error("Error in createTimelineEvent:", error);
                    showError("Failed to save timeline event.");
                    return null;
                }
            }
            
            async function addCharacterToEvent(eventId, charData) {
                try {
                    // Find the event element in the DOM
                    const eventElement = document.querySelector(`[data-event-id="${eventId}"]`);
                    if (!eventElement) {
                        console.error("Event element not found for ID:", eventId);
                        return;
                    }
                    
                    // Get current characters from the event
                    const characters = JSON.parse(eventElement.getAttribute('data-characters') || '[]');
                    
                    // Check if character already exists
                    if (characters.some(c => c.id === charData.id)) {
                        return; // Character already exists in the event
                    }
                    
                    // Add character to array
                    characters.push(charData);
                    
                    // Update local element
                    eventElement.setAttribute('data-characters', JSON.stringify(characters));
                    
                    // Update in database
                    const { error } = await window.supabaseModule.timelineEvents.update(
                        eventId,
                        { characters: JSON.stringify(characters) }
                    );
                    
                    if (error) {
                        console.error("Error updating event characters:", error);
                        showError("Failed to update event characters in database.");
                        
                        // Revert UI change if database update failed
                        eventElement.setAttribute('data-characters', JSON.stringify(
                            characters.filter(c => c.id !== charData.id)
                        ));
                        return;
                    }
                    
                    // If the event details panel is open and showing this event, update it
                    if (currentEventData && currentEventData.id === eventId) {
                        updateEventDetailsCharacters(characters);
                        currentEventData.characters = characters;
                    }
                } catch (error) {
                    console.error("Error in addCharacterToEvent:", error);
                    showError("Failed to add character to event.");
                }
            }
            
            function showEventDetails(e) {
                const eventElement = e.currentTarget;
                const panel = document.getElementById('eventDetailsPanel');
                
                currentEventData = {
                    id: eventElement.getAttribute('data-event-id'),
                    name: eventElement.textContent,
                    time: eventElement.getAttribute('data-time'),
                    description: eventElement.getAttribute('data-description'),
                    characters: JSON.parse(eventElement.getAttribute('data-characters') || '[]')
                };
                
                document.getElementById('eventDetailName').textContent = currentEventData.name;
                document.getElementById('eventDetailTime').textContent = `Time: ${currentEventData.time}`;
                document.getElementById('eventDetailDescription').textContent = currentEventData.description;
                
                updateEventDetailsCharacters(currentEventData.characters);
                
                panel.classList.remove('translate-x-full');
            }
            
            function updateEventDetailsCharacters(characters) {
                const container = document.getElementById('eventDetailCharacters');
                container.innerHTML = characters.map(char => `
                    <div class="flex items-center justify-between p-2 bg-gray-50 rounded">
                        <span class="flex items-center">
                            <div class="w-2 h-2 rounded-full ${getCharacterColorClass(char.role)} mr-2"></div>
                            ${char.name}
                        </span>
                        <button class="text-error hover:text-opacity-80" onclick="removeCharacterFromEvent('${currentEventData.id}', '${char.id}')">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `).join('');
            }
            
            function closeEventDetails() {
                document.getElementById('eventDetailsPanel').classList.add('translate-x-full');
                // Don't clear currentEventData here, as it might be needed for editing
            }
            
            // Helper function to reset the event modal and state
            function resetEventModalAndState() {
                document.getElementById('eventName').value = '';
                document.getElementById('eventTime').value = '';
                document.getElementById('eventDescription').value = '';
                document.getElementById('eventCreationModal').classList.add('hidden');
                document.getElementById('eventCreationModal').classList.remove('flex');
                document.querySelector('#eventCreationModal h2').textContent = 'Create Timeline Event';
                document.getElementById('createEvent').textContent = 'Create Event';
                
                // Clear event character list
                document.getElementById('eventCharacters').innerHTML = '';
                
                // Clear all state variables
                pendingEventCell = null;
                pendingEventCharacters = [];
                currentEventData = null;
                window.eventDataForEditing = null;
            }
            
            // Global functions needed for HTML access
            window.closeEventDetails = closeEventDetails;
            
            window.removeCharacterFromEvent = async function(eventId, characterId) {
                try {
                    const eventElement = document.querySelector(`[data-event-id="${eventId}"]`);
                    if (!eventElement) return;
                    
                    const characters = JSON.parse(eventElement.getAttribute('data-characters') || '[]');
                    const updatedCharacters = characters.filter(char => char.id !== characterId);
                    
                    // Update UI first for responsiveness
                    eventElement.setAttribute('data-characters', JSON.stringify(updatedCharacters));
                    
                    if (currentEventData && currentEventData.id === eventId) {
                        updateEventDetailsCharacters(updatedCharacters);
                        currentEventData.characters = updatedCharacters;
                    }
                    
                    // Update in database
                    const { error } = await window.supabaseModule.timelineEvents.update(
                        eventId,
                        { characters: JSON.stringify(updatedCharacters) }
                    );
                    
                    if (error) {
                        console.error("Error updating event characters:", error);
                        showError("Failed to remove character from event in database.");
                        
                        // Revert UI if database update failed
                        eventElement.setAttribute('data-characters', JSON.stringify(characters));
                        if (currentEventData && currentEventData.id === eventId) {
                            updateEventDetailsCharacters(characters);
                            currentEventData.characters = characters;
                        }
                    }
                } catch (error) {
                    console.error("Error in removeCharacterFromEvent:", error);
                    showError("Failed to remove character from event.");
                }
            };
            
            window.removeCharacterFromPending = function(characterName) {
                pendingEventCharacters = pendingEventCharacters.filter(char => char.name !== characterName);
                const charactersContainer = document.getElementById('eventCharacters');
                charactersContainer.innerHTML = pendingEventCharacters.map(char => `
                    <div class="flex items-center justify-between p-2 bg-white rounded">
                        <span class="flex items-center">
                            <div class="w-2 h-2 rounded-full ${getCharacterColorClass(char.role)} mr-2"></div>
                            ${char.name}
                        </span>
                        <button class="text-error hover:text-opacity-80" onclick="removeCharacterFromPending('${char.name}')">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `).join('');
            };
            
            window.editEvent = function() {
                if (!currentEventData) {
                    console.error("Error: No event selected for editing");
                    alert("No event selected for editing. Please try selecting an event first.");
                    return;
                }
                
                // Validate that we have the required event data
                if (!currentEventData.id) {
                    console.error("Error: Missing event ID for editing");
                    // Create a temporary ID if missing
                    currentEventData.id = 'temp-' + Date.now();
                    console.log("Created temporary ID for editing:", currentEventData.id);
                }
                
                console.log("Editing event with data:", currentEventData);
                
                // Populate the event creation modal with current event data
                document.getElementById('eventName').value = currentEventData.name || '';
                document.getElementById('eventTime').value = currentEventData.time || '';
                document.getElementById('eventDescription').value = currentEventData.description || '';
                pendingEventCharacters = Array.isArray(currentEventData.characters) ? [...currentEventData.characters] : [];
                
                // Update characters list in the modal
                const charactersContainer = document.getElementById('eventCharacters');
                charactersContainer.innerHTML = pendingEventCharacters.map(char => `
                    <div class="flex items-center justify-between p-2 bg-white rounded">
                        <span class="flex items-center">
                            <div class="w-2 h-2 rounded-full ${getCharacterColorClass(char.role)} mr-2"></div>
                            ${char.name}
                        </span>
                        <button class="text-error hover:text-opacity-80" onclick="removeCharacterFromPending('${char.name}')">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `).join('');
                
                // Update the modal title and button
                document.querySelector('#eventCreationModal h2').textContent = 'Edit Timeline Event';
                document.getElementById('createEvent').textContent = 'Update Event';
                
                // Find the original event element and its cell
                const eventElement = document.querySelector(`[data-event-id="${currentEventData.id}"]`);
                if (eventElement && eventElement.parentNode) {
                    pendingEventCell = eventElement.parentNode;
                } else {
                    console.error("Error: Could not find event element or its parent");
                    
                    // Try to find a matching cell based on time
                    const hourMatch = currentEventData.time ? currentEventData.time.match(/^(\d{1,2}):/) : null;
                    const hour = hourMatch ? parseInt(hourMatch[1]) : 0;
                    
                    // Find first cell with matching time in any location
                    pendingEventCell = document.querySelector(`.timeline-cell[data-time="${hour}"]`);
                    
                    if (!pendingEventCell) {
                        // As a last resort, use the first cell
                        pendingEventCell = document.querySelector('.timeline-cell');
                        console.log("Using fallback cell for event placement");
                    }
                }
                
                // Show the modal
                document.getElementById('eventCreationModal').classList.remove('hidden');
                document.getElementById('eventCreationModal').classList.add('flex');
                
                // Close the details panel
                closeEventDetails();
            };
            
            // Add event listeners for events
            document.addEventListener('DOMContentLoaded', function() {
                // Event Creation Modal Handlers
                document.getElementById('closeEventModal')?.addEventListener('click', () => {
                    document.getElementById('eventCreationModal').classList.add('hidden');
                    pendingEventCell = null;
                    pendingEventCharacters = [];
                });
                
                document.getElementById('cancelEvent')?.addEventListener('click', () => {
                    document.getElementById('eventCreationModal').classList.add('hidden');
                    pendingEventCell = null;
                    pendingEventCharacters = [];
                });
                
                // Edit Event button click handler
                document.getElementById('editEventBtn')?.addEventListener('click', window.editEvent);
                
                // Create/Update Event button handler
                document.getElementById('createEvent')?.addEventListener('click', async () => {
                    const name = document.getElementById('eventName').value.trim();
                    const time = document.getElementById('eventTime').value;
                    const description = document.getElementById('eventDescription').value.trim();
                    
                    if (!name) {
                        alert('Please enter an event name');
                        return;
                    }
                    
                    // Show loading state
                    const button = document.getElementById('createEvent');
                    const originalText = button.textContent;
                    button.disabled = true;
                    button.innerHTML = '<i class="fas fa-circle-notch fa-spin mr-1"></i>Saving...';
                    
                    try {
                        // Check if this is an update
                        const isUpdate = button.textContent.includes('Update');
                        
                        // Extract hour from the time for cell placement
                        const hourMatch = time.match(/^(\d{1,2}):/);
                        const hour = hourMatch ? parseInt(hourMatch[1]) : 0;
                        
                        if (isUpdate) {
                            // Handle event updates with Supabase
                            
                            // 1. Find the old event element
                            let oldEventElement = null;
                            
                            if (currentEventData && currentEventData.id) {
                                oldEventElement = document.querySelector(`[data-event-id="${currentEventData.id}"]`);
                                
                                // Remove any duplicate elements with the same ID
                                const duplicateElements = document.querySelectorAll(`[data-event-id="${currentEventData.id}"]`);
                                if (duplicateElements.length > 1) {
                                    duplicateElements.forEach((elem, idx) => {
                                        if (idx > 0 && elem.parentNode) {
                                            elem.parentNode.removeChild(elem);
                                        }
                                    });
                                }
                            }
                            
                            // 2. Determine target cell for placement
                            let targetLocation = (pendingEventCell ? pendingEventCell.getAttribute('data-location-id') : null);
                            let targetCell = null;
                            
                            // Find appropriate cell based on location and hour
                            if (targetLocation) {
                                targetCell = document.querySelector(`.timeline-cell[data-location-id="${targetLocation}"][data-time="${hour}"]`);
                            }
                            
                            // Fallbacks if target cell not found
                            if (!targetCell) {
                                if (pendingEventCell) {
                                    targetCell = pendingEventCell;
                                } else {
                                    // Use first cell with matching time
                                    targetCell = document.querySelector(`.timeline-cell[data-time="${hour}"]`);
                                    
                                    // Last resort: any cell
                                    if (!targetCell) {
                                        targetCell = document.querySelector('.timeline-cell');
                                    }
                                }
                            }
                            
                            // 3. Create/update event in Supabase and get UI element
                            const newEventElement = await createTimelineEvent(
                                name, time, description, pendingEventCharacters, true
                            );
                            
                            if (!newEventElement) {
                                throw new Error("Failed to create event element");
                            }
                            
                            // 4. Remove old element if it exists
                            if (oldEventElement && oldEventElement.parentNode) {
                                oldEventElement.parentNode.removeChild(oldEventElement);
                            }
                            
                            // 5. Add new element to target cell
                            if (targetCell) {
                                targetCell.appendChild(newEventElement);
                            }
                        } else {
                            // Handle new event creation with Supabase
                            
                            // 1. Find the appropriate cell for this hour
                            let targetCell = pendingEventCell;
                            
                            // If time changed, need to find the right cell
                            if (pendingEventCell) {
                                const currentCellHour = parseInt(pendingEventCell.getAttribute('data-time'));
                                if (currentCellHour !== hour) {
                                    const location = pendingEventCell.getAttribute('data-location-id');
                                    // Find cell with matching location and time
                                    const timeCell = document.querySelector(`.timeline-cell[data-location-id="${location}"][data-time="${hour}"]`);
                                    if (timeCell) {
                                        targetCell = timeCell;
                                    }
                                }
                            }
                            
                            // Fallback if no cell found
                            if (!targetCell) {
                                targetCell = document.querySelector(`.timeline-cell[data-time="${hour}"]`);
                                if (!targetCell) {
                                    targetCell = document.querySelector('.timeline-cell');
                                }
                            }
                            
                            // 2. Create event in Supabase and get element
                            const eventElement = await createTimelineEvent(
                                name, time, description, pendingEventCharacters, false
                            );
                            
                            if (!eventElement) {
                                throw new Error("Failed to create event element");
                            }
                            
                            // 3. Add to cell
                            if (targetCell) {
                                targetCell.appendChild(eventElement);
                            }
                        }
                        
                        // Reset modal and state
                        resetEventModalAndState();
                    } catch (error) {
                        console.error("Error creating/updating event:", error);
                        showError("Failed to save event. Please try again.");
                        
                        // Reset button state
                        button.disabled = false;
                        button.innerHTML = originalText;
                    }
                });
            });
            
            // Character functionality with Supabase integration
            function addCharacterToTree(character, posX, posY) {
                const characterTreeContainer = document.getElementById('characterTreeContainer');
                if (!characterTreeContainer) return;
                
                // Create node in character tree
                const nodeElement = document.createElement('div');
                nodeElement.className = 'character-node absolute bg-white p-2 rounded-lg shadow';
                nodeElement.setAttribute('data-character-id', character.id);
                nodeElement.setAttribute('data-name', character.name);
                nodeElement.setAttribute('data-role', character.role || 'Protagonist');
                nodeElement.setAttribute('data-traits', character.traits || '');
                nodeElement.setAttribute('data-backstory', character.backstory || '');
                
                // Position the node
                nodeElement.style.left = `${posX}px`;
                nodeElement.style.top = `${posY}px`;
                
                // Set appropriate color based on role
                let borderColorClass = 'border-primary';
                if (character.role === 'Antagonist') {
                    borderColorClass = 'border-error';
                } else if (character.role === 'Supporting') {
                    borderColorClass = 'border-accent';
                }
                
                nodeElement.innerHTML = `
                    <div class="w-full border-l-4 ${borderColorClass} pl-1">
                        <div class="text-sm font-medium">${character.name}</div>
                        <div class="text-xs text-gray-500">${character.role || 'Protagonist'}</div>
                    </div>
                `;
                
                // Add click handler
                nodeElement.onclick = function(e) {
                    e.stopPropagation();
                    showCharacterDetails(this);
                };
                
                // Add to container
                characterTreeContainer.appendChild(nodeElement);
                
                // Update relationship lines
                updateRelationshipLines();
                
                return nodeElement;
            }
            
            function updateCharacterRelationships(characters) {
                // This would need character relationship data from Supabase
                // For now, we'll just update the visual lines
                updateRelationshipLines();
            }
            
            function updateRelationshipLines() {
                const container = document.getElementById('characterTreeContainer');
                if (!container) return;
                
                const nodes = container.querySelectorAll('.character-node');
                
                // Remove all existing dynamic lines
                container.querySelectorAll('.character-link:not([data-static="true"])').forEach(link => link.remove());
                
                // Create a map of node positions
                const nodePositions = {};
                nodes.forEach(node => {
                    const rect = node.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();
                    
                    // Get node center position relative to container
                    const centerX = rect.left + rect.width/2 - containerRect.left;
                    const centerY = rect.top + rect.height/2 - containerRect.top;
                    
                    nodePositions[node.getAttribute('data-character-id')] = {
                        x: centerX,
                        y: centerY,
                        element: node
                    };
                });
                
                // In a real implementation, we would fetch relationship data from Supabase here
                // For now, just connect nodes that exist in a simple pattern
                const characterIds = Object.keys(nodePositions);
                
                // If we have at least 2 characters, create connections
                if (characterIds.length >= 2) {
                    // Connect first character to all others
                    const firstCharId = characterIds[0];
                    
                    for (let i = 1; i < characterIds.length; i++) {
                        const fromPos = nodePositions[firstCharId];
                        const toPos = nodePositions[characterIds[i]];
                        
                        if (fromPos && toPos) {
                            // Calculate line properties
                            const dx = toPos.x - fromPos.x;
                            const dy = toPos.y - fromPos.y;
                            const length = Math.sqrt(dx * dx + dy * dy);
                            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                            
                            // Create the line element
                            const line = document.createElement('div');
                            line.className = 'character-link';
                            line.style.width = `${length}px`;
                            line.style.left = `${fromPos.x}px`;
                            line.style.top = `${fromPos.y}px`;
                            line.style.transform = `rotate(${angle}deg)`;
                            
                            // Add to container
                            container.appendChild(line);
                        }
                    }
                }
            }
            
            function showCharacterDetails(node) {
                // Remove highlight from all nodes
                document.querySelectorAll('.character-node').forEach(n => {
                    n.style.boxShadow = '0 1px 3px rgba(0, 0, 0, 0.1)';
                });
                
                // Highlight the selected node
                node.style.boxShadow = '0 0 0 2px white, 0 0 0 4px var(--primary)';
                
                const panel = document.getElementById('characterDetailsPanel');
                const id = node.getAttribute('data-character-id');
                const name = node.getAttribute('data-name');
                const role = node.getAttribute('data-role');
                const traits = node.getAttribute('data-traits');
                const backstory = node.getAttribute('data-backstory');
                
                // Store current character data
                currentCharacterData = {
                    id,
                    name,
                    role,
                    traits,
                    backstory
                };
                
                // Update panel content
                document.getElementById('characterDetailName').textContent = name;
                
                const roleElement = document.getElementById('characterDetailRole');
                roleElement.textContent = role;
                roleElement.className = `role-badge ${role.toLowerCase()}`;
                
                document.getElementById('characterDetailTraits').textContent = traits || 'No traits specified';
                document.getElementById('characterDetailBackstory').textContent = backstory || 'No backstory available';
                
                // Show panel
                panel.classList.remove('translate-x-full');
            }
            
            function closeCharacterDetails() {
                // Remove highlight from all nodes
                document.querySelectorAll('.character-node').forEach(n => {
                    n.style.boxShadow = '0 1px 3px rgba(0, 0, 0, 0.1)';
                });
                
                const panel = document.getElementById('characterDetailsPanel');
                panel.classList.add('translate-x-full');
                currentCharacterData = null;
            }
            
            function setupCharacterCreation() {
                // Character Tree container click handler for adding new characters
                const characterTreeContainer = document.getElementById('characterTreeContainer');
                if (characterTreeContainer) {
                    characterTreeContainer.addEventListener('click', function(e) {
                        // Only register clicks directly on the container (not on nodes)
                        if (e.target === this || e.target.classList.contains('character-tree')) {
                            // Store the click position for potential character placement
                            const rect = this.getBoundingClientRect();
                            networkClickPosition = {
                                x: e.clientX - rect.left,
                                y: e.clientY - rect.top
                            };
                            
                            // Show the interaction overlay
                            const overlay = document.getElementById('networkInteractionOverlay');
                            if (overlay) {
                                overlay.style.display = 'block';
                                
                                // Position the overlay interaction button near the click
                                const overlayBtn = overlay.querySelector('div');
                                if (overlayBtn) {
                                    overlayBtn.style.left = networkClickPosition.x + 'px';
                                    overlayBtn.style.top = networkClickPosition.y + 'px';
                                }
                            }
                        }
                    });
                }
                
                // Add Character from Network button click handler
                const addCharacterFromNetworkBtn = document.getElementById('addCharacterFromNetworkBtn');
                if (addCharacterFromNetworkBtn) {
                    addCharacterFromNetworkBtn.addEventListener('click', function() {
                        // Hide the overlay
                        document.getElementById('networkInteractionOverlay').style.display = 'none';
                        
                        // Open the modal for new character
                        openModal('character', {
                            posX: networkClickPosition.x,
                            posY: networkClickPosition.y
                        });
                    });
                }
                
                // Hide network overlay when clicking anywhere else
                document.addEventListener('click', function(e) {
                    const overlay = document.getElementById('networkInteractionOverlay');
                    if (overlay && !e.target.closest('#characterTreeContainer')) {
                        overlay.style.display = 'none';
                    }
                    
                    // Close character details panel when clicking outside
                    const panel = document.getElementById('characterDetailsPanel');
                    const characterNodes = document.querySelectorAll('.character-node');
                    
                    if (panel && !panel.contains(e.target) && 
                        !Array.from(characterNodes).some(node => node.contains(e.target))) {
                        closeCharacterDetails();
                    }
                });
                
                // Make sure global functions are available
                window.closeCharacterDetails = closeCharacterDetails;
                
                // Set up the edit button for characters
                const editCharacterBtn = document.getElementById('editCharacterBtn');
                if (editCharacterBtn) {
                    editCharacterBtn.addEventListener('click', function() {
                        if (currentCharacterData) {
                            openModal('character', currentCharacterData);
                        }
                    });
                }
            }
            
            // Modal functionality for character creation/editing
            window.openModal = async function(type, data = null) {
                const modal = document.getElementById('addItemModal');
                const titleElement = modal.querySelector('h2');
                const typeSelectElement = modal.querySelector('#itemType');
                const nameInput = modal.querySelector('#itemName');
                const descriptionTextarea = modal.querySelector('#itemDescription');
                const roleSelect = modal.querySelector('#characterRole');
                
                // Clear previous data
                nameInput.value = '';
                descriptionTextarea.value = '';
                
                // Store data in modal for later use
                modal.dataset.posX = data && data.posX ? data.posX : '';
                modal.dataset.posY = data && data.posY ? data.posY : '';
                modal.dataset.characterId = data && data.id ? data.id : '';
                
                if (type === 'character') {
                    titleElement.textContent = data && data.id ? 'Edit Character' : 'Add New Character';
                    
                    // Select character type in dropdown
                    if (typeSelectElement) {
                        typeSelectElement.value = 'character';
                    }
                    
                    // Show character-specific fields
                    document.querySelectorAll('.character-field').forEach(field => {
                        field.classList.remove('hidden');
                    });
                    
                    // Hide location-specific fields
                    document.querySelectorAll('.location-field').forEach(field => {
                        field.classList.add('hidden');
                    });
                    
                    if (data && data.id) {
                        // Pre-fill with character data
                        nameInput.value = data.name || '';
                        
                        // Set role if it exists
                        if (roleSelect && data.role) {
                            roleSelect.value = data.role;
                        }
                        
                        // Format description based on traits and backstory
                        let description = '';
                        if (data.traits) description += data.traits;
                        if (data.backstory) {
                            if (description) description += '\n\n';
                            description += data.backstory;
                        }
                        descriptionTextarea.value = description;
                    }
                }
                
                // Show the modal
                modal.classList.remove('hidden');
                nameInput.focus();
            };
            
            window.closeModal = function() {
                const modal = document.getElementById('addItemModal');
                modal.classList.add('hidden');
                
                // Reset form fields
                modal.querySelectorAll('input[type="text"], textarea, select').forEach(input => {
                    input.value = '';
                });
                
                // Clear stored data
                delete modal.dataset.posX;
                delete modal.dataset.posY;
                delete modal.dataset.characterId;
            };
            
            window.saveItem = async function() {
                const modal = document.getElementById('addItemModal');
                const typeSelectElement = modal.querySelector('#itemType');
                const nameInput = modal.querySelector('#itemName');
                const descriptionTextarea = modal.querySelector('#itemDescription');
                const roleSelect = modal.querySelector('#characterRole');
                
                const itemType = typeSelectElement ? typeSelectElement.value : 'character';
                const name = nameInput.value.trim();
                const description = descriptionTextarea.value.trim();
                
                // Validate input
                if (!name) {
                    alert('Please enter a name');
                    return;
                }
                
                // Show loading state
                const saveBtn = document.querySelector('#addItemModal button[onclick="saveItem()"]');
                const originalText = saveBtn.textContent;
                saveBtn.disabled = true;
                saveBtn.innerHTML = '<i class="fas fa-circle-notch fa-spin mr-1"></i>Saving...';
                
                try {
                    if (itemType === 'character') {
                        // Parse traits and backstory from description
                        // For simplicity, we'll use the entire description as traits for now
                        const traits = description;
                        const backstory = '';
                        
                        // Get role from the select
                        const role = roleSelect ? roleSelect.value : 'Protagonist';
                        
                        // Check if this is an edit or a new character
                        const characterId = modal.dataset.characterId;
                        
                        // Prepare character data
                        const characterData = {
                            name,
                            role,
                            traits,
                            backstory,
                            project_id: currentProjectId
                        };
                        
                        // Save to Supabase
                        let result;
                        
                        if (characterId) {
                            // Update existing character
                            result = await window.supabaseModule.characters.update(
                                characterId,
                                characterData
                            );
                        } else {
                            // Create new character
                            result = await window.supabaseModule.characters.create(characterData);
                        }
                        
                        const { data: character, error } = result;
                        
                        if (error) {
                            console.error('Error saving character:', error);
                            showError('Failed to save character. Please try again.');
                            return;
                        }
                        
                        // Handle UI updates
                        if (characterId) {
                            // Update existing character in the UI
                            const characterNode = document.querySelector(`.character-node[data-character-id="${characterId}"]`);
                            if (characterNode) {
                                characterNode.setAttribute('data-name', name);
                                characterNode.setAttribute('data-role', role);
                                characterNode.setAttribute('data-traits', traits);
                                characterNode.setAttribute('data-backstory', backstory);
                                
                                // Update node content
                                let borderColorClass = 'border-primary';
                                if (role === 'Antagonist') {
                                    borderColorClass = 'border-error';
                                } else if (role === 'Supporting') {
                                    borderColorClass = 'border-accent';
                                }
                                
                                characterNode.innerHTML = `
                                    <div class="w-full border-l-4 ${borderColorClass} pl-1">
                                        <div class="text-sm font-medium">${name}</div>
                                        <div class="text-xs text-gray-500">${role}</div>
                                    </div>
                                `;
                                
                                // Also update in the character list
                                const listItem = document.querySelector(`.character-item[data-character-id="${characterId}"]`);
                                if (listItem) {
                                    listItem.setAttribute('data-name', name);
                                    listItem.setAttribute('data-role', role);
                                    
                                    let borderColorClass = 'border-primary';
                                    let textColorClass = 'text-primary';
                                    
                                    if (role === 'Antagonist') {
                                        borderColorClass = 'border-error';
                                        textColorClass = 'text-error';
                                    } else if (role === 'Supporting') {
                                        borderColorClass = 'border-accent';
                                        textColorClass = 'text-accent';
                                    }
                                    
                                    // Update classes
                                    listItem.className = `character-item bg-white border-2 ${borderColorClass} ${textColorClass} p-2 rounded-lg cursor-move shadow-sm`;
                                    
                                    // Update content
                                    listItem.innerHTML = `
                                        <div class="text-sm font-medium">${name}</div>
                                    `;
                                }
                            }
                        } else {
                            // Add new character to the UI
                            const characterTreeContainer = document.getElementById('characterTreeContainer');
                            if (characterTreeContainer) {
                                // Position from click or default
                                const posX = parseFloat(modal.dataset.posX) || 100;
                                const posY = parseFloat(modal.dataset.posY) || 100;
                                
                                // Add to tree
                                addCharacterToTree(character, posX, posY);
                                
                                // Add to character list
                                const characterList = document.getElementById('charactersList');
                                if (characterList) {
                                    // Add character to list for dragging
                                    let borderColorClass = 'border-primary';
                                    let textColorClass = 'text-primary';
                                    
                                    if (role === 'Antagonist') {
                                        borderColorClass = 'border-error';
                                        textColorClass = 'text-error';
                                    } else if (role === 'Supporting') {
                                        borderColorClass = 'border-accent';
                                        textColorClass = 'text-accent';
                                    }
                                    
                                    const characterItem = document.createElement('div');
                                    characterItem.className = `character-item bg-white border-2 ${borderColorClass} ${textColorClass} p-2 rounded-lg cursor-move shadow-sm`;
                                    characterItem.setAttribute('draggable', 'true');
                                    characterItem.setAttribute('data-character-id', character.id);
                                    characterItem.setAttribute('data-name', name);
                                    characterItem.setAttribute('data-role', role);
                                    
                                    characterItem.innerHTML = `
                                        <div class="text-sm font-medium">${name}</div>
                                    `;
                                    
                                    // Add to character list
                                    characterList.appendChild(characterItem);
                                    
                                    // Add drag event listener
                                    characterItem.addEventListener('dragstart', handleCharacterDragStart);
                                    
                                    // If first character, remove empty state
                                    const emptyState = characterList.querySelector('.text-center.py-6');
                                    if (emptyState) {
                                        emptyState.remove();
                                    }
                                    
                                    // Update character count
                                    const characterCountElement = document.querySelector('#characterTreeView span.text-xs');
                                    if (characterCountElement) {
                                        const count = characterList.querySelectorAll('.character-item').length;
                                        characterCountElement.textContent = `${count} character${count !== 1 ? 's' : ''}`;
                                    }
                                }
                            }
                        }
                        
                        // Close modal
                        closeModal();
                    }
                } catch (error) {
                    console.error('Error saving item:', error);
                    showError('Failed to save item. Please try again.');
                } finally {
                    // Reset button
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = originalText;
                }
            };
            
            // Add event listeners for characters
            document.addEventListener('DOMContentLoaded', function() {
                // Set up character creation functionality
                setupCharacterCreation();
                
                // Add Characters button
                document.getElementById('addCharacterBtn')?.addEventListener('click', () => {
                    openModal('character');
                });
            });
            
            // Initialize the application on load
            addDragDropStyles();
            initializeApp();
        });
    </script>
</body>
</html> 